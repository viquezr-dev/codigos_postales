<!DOCTYPE html>
<html>
<head>
    <title>PanamaCode - Sistema Postal</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 250px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .leaflet-top.leaflet-right { top: 80px !important; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 14px; font-weight: bold; }
        .micro-label-fixed { background: none!important; border:none!important; color: #3498db!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 11px; font-weight: bold; }
        .nano-label-fixed { background: none!important; border:none!important; color: #2980b9!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .micro-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-cell { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { fill-opacity: 0.3; stroke-width: 3; }
            50% { fill-opacity: 0.6; stroke-width: 4; }
            100% { fill-opacity: 0.3; stroke-width: 3; }
        }
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }
        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        .code-display {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            color: #2c3e50;
            letter-spacing: 1px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 2px solid #3498db;
            margin: 10px 0;
            text-align: center;
        }
        .simple-popup { min-width: 200px; }
        .grid-line { pointer-events: none; }
    </style>
</head>
<body>

<div class="map-title"><h1>PanamaCode - Sistema Postal</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: 8A9B-X3Y7-Z5W2">
    <button id="search-btn">BUSCAR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

<script>
// ==================== CONFIGURACI칍N ====================
const mymap = L.map('mapid').setView([8.50, -80.0], 10); // Empezar en zoom 10
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let labelsEnabled = true;

// ==================== SISTEMA PanamaCode UNIVERSAL ====================

// Base32 optimizada
const BASE32 = "23456789ABCDEFGHJKMNPQRSTUVWXYZ";

// 츼rea de cobertura de Panam치
const PANAMA_BOUNDS = {
    south: 7.0,
    north: 9.8,
    west: -83.0,
    east: -77.0
};

// Configuraci칩n de grid M츼S PEQUE칌A
const GRID_CONFIG = {
    regionSize: 0.5,      // ~55km
    sectorSize: 0.02,     // ~2.2km (m치s peque침o)
    cellSize: 0.0008,     // ~90m (m치s peque침o)
    regionChars: 4,
    sectorChars: 4,
    cellChars: 4
};

// Codificar n칰mero a Base32 (2 caracteres)
function encodeBase32(num) {
    const char1 = BASE32[Math.floor(num / 32) % 32];
    const char2 = BASE32[num % 32];
    return char1 + char2;
}

// Decodificar Base32
function decodeBase32(str) {
    const map = {};
    for (let i = 0; i < BASE32.length; i++) {
        map[BASE32[i]] = i;
    }
    return (map[str[0]] || 0) * 32 + (map[str[1]] || 0);
}

// Calcular 칤ndices desde coordenadas
function latLngToIndices(lat, lng) {
    const relX = (lng - PANAMA_BOUNDS.west) / (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west);
    const relY = (lat - PANAMA_BOUNDS.south) / (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south);
    
    const safeRelX = Math.max(0.0001, Math.min(0.9999, relX));
    const safeRelY = Math.max(0.0001, Math.min(0.9999, relY));
    
    // Calcular n칰mero total de celdas
    const regionCellsX = Math.floor((PANAMA_BOUNDS.east - PANAMA_BOUNDS.west) / GRID_CONFIG.regionSize);
    const regionCellsY = Math.floor((PANAMA_BOUNDS.north - PANAMA_BOUNDS.south) / GRID_CONFIG.regionSize);
    const sectorCellsX = Math.floor((PANAMA_BOUNDS.east - PANAMA_BOUNDS.west) / GRID_CONFIG.sectorSize);
    const sectorCellsY = Math.floor((PANAMA_BOUNDS.north - PANAMA_BOUNDS.south) / GRID_CONFIG.sectorSize);
    const cellCellsX = Math.floor((PANAMA_BOUNDS.east - PANAMA_BOUNDS.west) / GRID_CONFIG.cellSize);
    const cellCellsY = Math.floor((PANAMA_BOUNDS.north - PANAMA_BOUNDS.south) / GRID_CONFIG.cellSize);
    
    return {
        region: {
            x: Math.floor(safeRelX * regionCellsX),
            y: Math.floor(safeRelY * regionCellsY)
        },
        sector: {
            x: Math.floor(safeRelX * sectorCellsX),
            y: Math.floor(safeRelY * sectorCellsY)
        },
        cell: {
            x: Math.floor(safeRelX * cellCellsX),
            y: Math.floor(safeRelY * cellCellsY)
        }
    };
}

// Generar PanamaCode completo
function generatePanamaCode(lat, lng) {
    const indices = latLngToIndices(lat, lng);
    
    const regionCode = encodeBase32(indices.region.x) + encodeBase32(indices.region.y);
    const sectorCode = encodeBase32(indices.sector.x % 1024) + encodeBase32(indices.sector.y % 1024);
    const cellCode = encodeBase32(indices.cell.x % 1024) + encodeBase32(indices.cell.y % 1024);
    
    return `${regionCode}-${sectorCode}-${cellCode}`;
}

// Decodificar PanamaCode a coordenadas
function decodePanamaCode(code) {
    const parts = code.split('-');
    if (parts.length !== 3) return null;
    
    const [regionCode, sectorCode, cellCode] = parts;
    
    const regionX = decodeBase32(regionCode.substring(0, 2));
    const regionY = decodeBase32(regionCode.substring(2, 4));
    const sectorX = decodeBase32(sectorCode.substring(0, 2));
    const sectorY = decodeBase32(sectorCode.substring(2, 4));
    const cellX = decodeBase32(cellCode.substring(0, 2));
    const cellY = decodeBase32(cellCode.substring(2, 4));
    
    // Calcular n칰mero total de celdas
    const regionCellsX = Math.floor((PANAMA_BOUNDS.east - PANAMA_BOUNDS.west) / GRID_CONFIG.regionSize);
    const regionCellsY = Math.floor((PANAMA_BOUNDS.north - PANAMA_BOUNDS.south) / GRID_CONFIG.regionSize);
    const sectorCellsX = Math.floor((PANAMA_BOUNDS.east - PANAMA_BOUNDS.west) / GRID_CONFIG.sectorSize);
    const sectorCellsY = Math.floor((PANAMA_BOUNDS.north - PANAMA_BOUNDS.south) / GRID_CONFIG.sectorSize);
    const cellCellsX = Math.floor((PANAMA_BOUNDS.east - PANAMA_BOUNDS.west) / GRID_CONFIG.cellSize);
    const cellCellsY = Math.floor((PANAMA_BOUNDS.north - PANAMA_BOUNDS.south) / GRID_CONFIG.cellSize);
    
    // Calcular posici칩n relativa
    const relX = (regionX / regionCellsX) + 
                 ((sectorX % 1024) / (1024 * regionCellsX)) + 
                 ((cellX % 1024) / (1024 * 1024 * regionCellsX));
    
    const relY = (regionY / regionCellsY) + 
                 ((sectorY % 1024) / (1024 * regionCellsY)) + 
                 ((cellY % 1024) / (1024 * 1024 * regionCellsY));
    
    // Calcular coordenadas
    const lng = PANAMA_BOUNDS.west + relX * (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west);
    const lat = PANAMA_BOUNDS.south + relY * (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south);
    
    // Calcular bounds de la celda
    const cellBounds = [
        [lat - GRID_CONFIG.cellSize/2, lng - GRID_CONFIG.cellSize/2],
        [lat - GRID_CONFIG.cellSize/2, lng + GRID_CONFIG.cellSize/2],
        [lat + GRID_CONFIG.cellSize/2, lng + GRID_CONFIG.cellSize/2],
        [lat + GRID_CONFIG.cellSize/2, lng - GRID_CONFIG.cellSize/2]
    ];
    
    return {
        lat,
        lng,
        bounds: cellBounds,
        regionCode,
        sectorCode,
        cellCode
    };
}

// ==================== VISUALIZACI칍N DE GRID ====================

function updateGridAndLabels() {
    gridLayer.clearLayers();
    labelLayer.clearLayers();
    
    const z = mymap.getZoom();
    const bounds = mymap.getBounds();
    
    // Asegurar que siempre haya grid visible
    if (z >= 10) {
        drawGrid(z, bounds);
    }
}

function drawGrid(zoom, bounds) {
    console.log(`Dibujando grid para zoom: ${zoom}`);
    
    // SIEMPRE dibujar algo visible
    if (zoom >= 10 && zoom < 14) {
        console.log("Dibujando grid de regiones");
        drawRegionGrid(bounds);
        
        if (labelsEnabled) {
            console.log("Dibujando labels de regi칩n");
            drawRegionLabels(bounds);
        }
    }
    
    if (zoom >= 14 && zoom < 17) {
        console.log("Dibujando grid de sectores");
        drawSectorGrid(bounds);
        
        if (labelsEnabled) {
            console.log("Dibujando labels de sector");
            drawSectorLabels(bounds);
        }
    }
    
    if (zoom >= 17) {
        console.log("Dibujando grid de celdas");
        drawCellGrid(bounds);
        
        if (labelsEnabled && zoom >= 18) {
            console.log("Dibujando labels de celda");
            drawCellLabels(bounds);
        }
    }
}

function drawRegionGrid(bounds) {
    const startLng = Math.floor(bounds.getWest() / GRID_CONFIG.regionSize) * GRID_CONFIG.regionSize;
    const endLng = Math.ceil(bounds.getEast() / GRID_CONFIG.regionSize) * GRID_CONFIG.regionSize;
    const startLat = Math.floor(bounds.getSouth() / GRID_CONFIG.regionSize) * GRID_CONFIG.regionSize;
    const endLat = Math.ceil(bounds.getNorth() / GRID_CONFIG.regionSize) * GRID_CONFIG.regionSize;
    
    // L칤neas verticales - MUY VISIBLES
    for (let lng = startLng; lng <= endLng; lng += GRID_CONFIG.regionSize) {
        L.polyline([
            [Math.max(bounds.getSouth(), PANAMA_BOUNDS.south), lng],
            [Math.min(bounds.getNorth(), PANAMA_BOUNDS.north), lng]
        ], {
            color: '#1a73e8',
            weight: 3,  // M츼S GRUESO
            opacity: 0.8,  // M츼S VISIBLE
            dashArray: '6, 6',
            className: 'grid-line'
        }).addTo(gridLayer);
    }
    
    // L칤neas horizontales - MUY VISIBLES
    for (let lat = startLat; lat <= endLat; lat += GRID_CONFIG.regionSize) {
        L.polyline([
            [lat, Math.max(bounds.getWest(), PANAMA_BOUNDS.west)],
            [lat, Math.min(bounds.getEast(), PANAMA_BOUNDS.east)]
        ], {
            color: '#1a73e8',
            weight: 3,  // M츼S GRUESO
            opacity: 0.8,  // M츼S VISIBLE
            dashArray: '6, 6',
            className: 'grid-line'
        }).addTo(gridLayer);
    }
}

function drawSectorGrid(bounds) {
    const startLng = Math.floor(bounds.getWest() / GRID_CONFIG.sectorSize) * GRID_CONFIG.sectorSize;
    const endLng = Math.ceil(bounds.getEast() / GRID_CONFIG.sectorSize) * GRID_CONFIG.sectorSize;
    const startLat = Math.floor(bounds.getSouth() / GRID_CONFIG.sectorSize) * GRID_CONFIG.sectorSize;
    const endLat = Math.ceil(bounds.getNorth() / GRID_CONFIG.sectorSize) * GRID_CONFIG.sectorSize;
    
    // L칤neas verticales - VISIBLES
    for (let lng = startLng; lng <= endLng; lng += GRID_CONFIG.sectorSize) {
        L.polyline([
            [Math.max(bounds.getSouth(), PANAMA_BOUNDS.south), lng],
            [Math.min(bounds.getNorth(), PANAMA_BOUNDS.north), lng]
        ], {
            color: '#3498db',
            weight: 2,  // VISIBLE
            opacity: 0.6,
            dashArray: '4, 4',
            className: 'grid-line'
        }).addTo(gridLayer);
    }
    
    // L칤neas horizontales - VISIBLES
    for (let lat = startLat; lat <= endLat; lat += GRID_CONFIG.sectorSize) {
        L.polyline([
            [lat, Math.max(bounds.getWest(), PANAMA_BOUNDS.west)],
            [lat, Math.min(bounds.getEast(), PANAMA_BOUNDS.east)]
        ], {
            color: '#3498db',
            weight: 2,  // VISIBLE
            opacity: 0.6,
            dashArray: '4, 4',
            className: 'grid-line'
        }).addTo(gridLayer);
    }
}

function drawCellGrid(bounds) {
    const startLng = Math.floor(bounds.getWest() / GRID_CONFIG.cellSize) * GRID_CONFIG.cellSize;
    const endLng = Math.ceil(bounds.getEast() / GRID_CONFIG.cellSize) * GRID_CONFIG.cellSize;
    const startLat = Math.floor(bounds.getSouth() / GRID_CONFIG.cellSize) * GRID_CONFIG.cellSize;
    const endLat = Math.ceil(bounds.getNorth() / GRID_CONFIG.cellSize) * GRID_CONFIG.cellSize;
    
    // L칤neas verticales (cada 10 para no saturar)
    for (let lng = startLng; lng <= endLng; lng += GRID_CONFIG.cellSize * 10) {
        L.polyline([
            [bounds.getSouth(), lng],
            [bounds.getNorth(), lng]
        ], {
            color: '#2980b9',
            weight: 1,
            opacity: 0.4,
            dashArray: '2, 2',
            className: 'grid-line'
        }).addTo(gridLayer);
    }
    
    // L칤neas horizontales (cada 10 para no saturar)
    for (let lat = startLat; lat <= endLat; lat += GRID_CONFIG.cellSize * 10) {
        L.polyline([
            [lat, bounds.getWest()],
            [lat, bounds.getEast()]
        ], {
            color: '#2980b9',
            weight: 1,
            opacity: 0.4,
            dashArray: '2, 2',
            className: 'grid-line'
        }).addTo(gridLayer);
    }
}

function drawRegionLabels(bounds) {
    const startX = Math.floor((bounds.getWest() - PANAMA_BOUNDS.west) / GRID_CONFIG.regionSize);
    const endX = Math.ceil((bounds.getEast() - PANAMA_BOUNDS.west) / GRID_CONFIG.regionSize);
    const startY = Math.floor((bounds.getSouth() - PANAMA_BOUNDS.south) / GRID_CONFIG.regionSize);
    const endY = Math.ceil((bounds.getNorth() - PANAMA_BOUNDS.south) / GRID_CONFIG.regionSize);
    
    for (let x = Math.max(0, startX); x <= Math.min(endX, 32); x++) {
        for (let y = Math.max(0, startY); y <= Math.min(endY, 32); y++) {
            const centerLng = PANAMA_BOUNDS.west + (x + 0.5) * GRID_CONFIG.regionSize;
            const centerLat = PANAMA_BOUNDS.south + (y + 0.5) * GRID_CONFIG.regionSize;
            
            if (bounds.contains([centerLat, centerLng]) && 
                centerLat >= PANAMA_BOUNDS.south && centerLat <= PANAMA_BOUNDS.north &&
                centerLng >= PANAMA_BOUNDS.west && centerLng <= PANAMA_BOUNDS.east) {
                
                const regionCode = encodeBase32(x) + encodeBase32(y);
                
                L.marker([centerLat, centerLng], {
                    icon: L.divIcon({ 
                        className: 'watermark-label-fixed', 
                        html: `<div style="background: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 3px;">${regionCode}</div>`, 
                        iconSize: [50, 25] 
                    })
                }).addTo(labelLayer);
            }
        }
    }
}

function drawSectorLabels(bounds) {
    const startX = Math.floor((bounds.getWest() - PANAMA_BOUNDS.west) / GRID_CONFIG.sectorSize);
    const endX = Math.ceil((bounds.getEast() - PANAMA_BOUNDS.west) / GRID_CONFIG.sectorSize);
    const startY = Math.floor((bounds.getSouth() - PANAMA_BOUNDS.south) / GRID_CONFIG.sectorSize);
    const endY = Math.ceil((bounds.getNorth() - PANAMA_BOUNDS.south) / GRID_CONFIG.sectorSize);
    
    // Mostrar cada 2 sectores
    for (let x = Math.max(0, startX); x <= endX; x += 2) {
        for (let y = Math.max(0, startY); y <= endY; y += 2) {
            const centerLng = PANAMA_BOUNDS.west + (x + 0.5) * GRID_CONFIG.sectorSize;
            const centerLat = PANAMA_BOUNDS.south + (y + 0.5) * GRID_CONFIG.sectorSize;
            
            if (bounds.contains([centerLat, centerLng]) &&
                centerLat >= PANAMA_BOUNDS.south && centerLat <= PANAMA_BOUNDS.north &&
                centerLng >= PANAMA_BOUNDS.west && centerLng <= PANAMA_BOUNDS.east) {
                
                const sectorCode = encodeBase32(x % 1024) + encodeBase32(y % 1024);
                
                L.marker([centerLat, centerLng], {
                    icon: L.divIcon({ 
                        className: 'micro-label-fixed', 
                        html: `<div style="background: rgba(255,255,255,0.7); padding: 1px 4px; border-radius: 2px;">${sectorCode}</div>`, 
                        iconSize: [40, 18] 
                    })
                }).addTo(labelLayer);
            }
        }
    }
}

function drawCellLabels(bounds) {
    const startX = Math.floor((bounds.getWest() - PANAMA_BOUNDS.west) / GRID_CONFIG.cellSize);
    const endX = Math.ceil((bounds.getEast() - PANAMA_BOUNDS.west) / GRID_CONFIG.cellSize);
    const startY = Math.floor((bounds.getSouth() - PANAMA_BOUNDS.south) / GRID_CONFIG.cellSize);
    const endY = Math.ceil((bounds.getNorth() - PANAMA_BOUNDS.south) / GRID_CONFIG.cellSize);
    
    // Mostrar solo algunas celdas (cada 20)
    for (let x = Math.max(0, startX); x <= endX; x += 20) {
        for (let y = Math.max(0, startY); y <= endY; y += 20) {
            const centerLng = PANAMA_BOUNDS.west + (x + 0.5) * GRID_CONFIG.cellSize;
            const centerLat = PANAMA_BOUNDS.south + (y + 0.5) * GRID_CONFIG.cellSize;
            
            if (bounds.contains([centerLat, centerLng]) &&
                centerLat >= PANAMA_BOUNDS.south && centerLat <= PANAMA_BOUNDS.north &&
                centerLng >= PANAMA_BOUNDS.west && centerLng <= PANAMA_BOUNDS.east) {
                
                const cellCode = encodeBase32(x % 1024) + encodeBase32(y % 1024);
                
                L.marker([centerLat, centerLng], {
                    icon: L.divIcon({ 
                        className: 'nano-label-fixed', 
                        html: `<div style="background: rgba(255,255,255,0.7); padding: 0px 2px; border-radius: 1px; font-size: 8px;">${cellCode}</div>`, 
                        iconSize: [30, 12] 
                    })
                }).addTo(labelLayer);
            }
        }
    }
}

// ==================== EVENTO CLIC (3 NIVELES) ====================

mymap.on("click", function (e) {
    selectionLayer.clearLayers();
    
    const lat = e.latlng.lat;
    const lng = e.latlng.lng;
    const z = mymap.getZoom();
    
    // Verificar si est치 dentro de Panam치
    if (lat < PANAMA_BOUNDS.south || lat > PANAMA_BOUNDS.north || 
        lng < PANAMA_BOUNDS.west || lng > PANAMA_BOUNDS.east) {
        showNoCodePopup(e.latlng, "Fuera de Panam치");
        return;
    }
    
    // Generar c칩digo
    const fullCode = generatePanamaCode(lat, lng);
    const [regionCode, sectorCode, cellCode] = fullCode.split('-');
    
    let displayCode = '';
    let titulo = '';
    let highlightBounds = null;
    
    // NIVEL MACRO (zoom < 14) - REGI칍N
    if (z < 14) {
        titulo = "REGI칍N";
        displayCode = regionCode;
        
        const indices = latLngToIndices(lat, lng);
        const centerLng = PANAMA_BOUNDS.west + (indices.region.x + 0.5) * GRID_CONFIG.regionSize;
        const centerLat = PANAMA_BOUNDS.south + (indices.region.y + 0.5) * GRID_CONFIG.regionSize;
        
        highlightBounds = [
            [centerLat - GRID_CONFIG.regionSize/2, centerLng - GRID_CONFIG.regionSize/2],
            [centerLat - GRID_CONFIG.regionSize/2, centerLng + GRID_CONFIG.regionSize/2],
            [centerLat + GRID_CONFIG.regionSize/2, centerLng + GRID_CONFIG.regionSize/2],
            [centerLat + GRID_CONFIG.regionSize/2, centerLng - GRID_CONFIG.regionSize/2]
        ];
    }
    
    // NIVEL MICRO (zoom 14-16) - SECTOR
    else if (z >= 14 && z < 17) {
        titulo = "SECTOR";
        displayCode = `${regionCode}-${sectorCode}`;
        
        const indices = latLngToIndices(lat, lng);
        const centerLng = PANAMA_BOUNDS.west + (indices.sector.x + 0.5) * GRID_CONFIG.sectorSize;
        const centerLat = PANAMA_BOUNDS.south + (indices.sector.y + 0.5) * GRID_CONFIG.sectorSize;
        
        highlightBounds = [
            [centerLat - GRID_CONFIG.sectorSize/2, centerLng - GRID_CONFIG.sectorSize/2],
            [centerLat - GRID_CONFIG.sectorSize/2, centerLng + GRID_CONFIG.sectorSize/2],
            [centerLat + GRID_CONFIG.sectorSize/2, centerLng + GRID_CONFIG.sectorSize/2],
            [centerLat + GRID_CONFIG.sectorSize/2, centerLng - GRID_CONFIG.sectorSize/2]
        ];
    }
    
    // NIVEL NANO (zoom 17+) - CELDA
    else {
        titulo = "CELDA";
        displayCode = fullCode;
        
        const indices = latLngToIndices(lat, lng);
        const centerLng = PANAMA_BOUNDS.west + (indices.cell.x + 0.5) * GRID_CONFIG.cellSize;
        const centerLat = PANAMA_BOUNDS.south + (indices.cell.y + 0.5) * GRID_CONFIG.cellSize;
        
        highlightBounds = [
            [centerLat - GRID_CONFIG.cellSize/2, centerLng - GRID_CONFIG.cellSize/2],
            [centerLat - GRID_CONFIG.cellSize/2, centerLng + GRID_CONFIG.cellSize/2],
            [centerLat + GRID_CONFIG.cellSize/2, centerLng + GRID_CONFIG.cellSize/2],
            [centerLat + GRID_CONFIG.cellSize/2, centerLng - GRID_CONFIG.cellSize/2]
        ];
        
        // Borde del sector para referencia
        const sectorCenterLng = PANAMA_BOUNDS.west + (indices.sector.x + 0.5) * GRID_CONFIG.sectorSize;
        const sectorCenterLat = PANAMA_BOUNDS.south + (indices.sector.y + 0.5) * GRID_CONFIG.sectorSize;
        
        const sectorBounds = [
            [sectorCenterLat - GRID_CONFIG.sectorSize/2, sectorCenterLng - GRID_CONFIG.sectorSize/2],
            [sectorCenterLat - GRID_CONFIG.sectorSize/2, sectorCenterLng + GRID_CONFIG.sectorSize/2],
            [sectorCenterLat + GRID_CONFIG.sectorSize/2, sectorCenterLng + GRID_CONFIG.sectorSize/2],
            [sectorCenterLat + GRID_CONFIG.sectorSize/2, sectorCenterLng - GRID_CONFIG.sectorSize/2]
        ];
        
        L.polygon(sectorBounds, {
            color: "#3498db",
            weight: 1,
            fillColor: "transparent",
            dashArray: "5, 5",
            opacity: 0.5
        }).addTo(selectionLayer);
    }
    
    // Destacar celda
    if (highlightBounds) {
        const color = z < 14 ? "#1a73e8" : (z < 17 ? "#3498db" : "#2980b9");
        
        L.polygon(highlightBounds, {
            color: color,
            weight: 3,
            fillColor: color,
            fillOpacity: 0.3,
            className: 'highlighted-cell'
        }).addTo(selectionLayer);
    }
    
    // Popup simple
    showSimplePopup(e.latlng, titulo, displayCode);
});

function showNoCodePopup(latlng, mensaje) {
    L.popup({ className: 'warning-popup' })
        .setLatLng([latlng.lat, latlng.lng])
        .setContent(`
            <div class="simple-popup">
                <div style="text-align:center; padding: 10px;">
                    <div style="color: #e74c3c; font-size: 14px; margin-bottom: 5px;">
                        丘멆잺 ${mensaje}
                    </div>
                </div>
            </div>
        `)
        .openOn(mymap);
}

function showSimplePopup(latlng, titulo, codigo) {
    const ws = encodeURIComponent(`游늸 ${codigo}\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`);
    
    const popup = L.popup({ className: 'simple-popup' })
        .setLatLng([latlng.lat, latlng.lng])
        .setContent(`
            <div style="text-align:center; padding: 10px;">
                <small>${titulo}</small><br>
                <div class="code-display" style="font-size: 14px;">${codigo}</div>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">游늸 MAPS</button>
                <button class="btn-ws" onclick="window.open('https://wa.me/?text=${ws}')">游눫 WS</button>
            </div>
        `)
        .openOn(mymap);
    
    popup.on('remove', () => {
        selectionLayer.clearLayers();
    });
}

// ==================== BUSCADOR ====================

document.getElementById('search-btn').addEventListener('click', () => {
    const code = document.getElementById('search-input').value.trim().toUpperCase();
    
    if (!code) return;
    
    const decoded = decodePanamaCode(code);
    
    if (!decoded) {
        alert('C칩digo no v치lido: ' + code);
        return;
    }
    
    selectionLayer.clearLayers();
    
    // Determinar nivel por n칰mero de partes
    const parts = code.split('-');
    let zoomLevel = 12;
    
    if (parts.length === 1 || parts.length === 2) {
        zoomLevel = 14;
    } else if (parts.length === 3) {
        zoomLevel = 18;
    }
    
    // Centrar mapa
    mymap.setView([decoded.lat, decoded.lng], zoomLevel);
    
    // Destacar celda
    L.polygon(decoded.bounds, {
        color: '#e74c3c',
        weight: 3,
        fillColor: '#e74c3c',
        fillOpacity: 0.3
    }).addTo(selectionLayer);
});

// ==================== CONTROLES ====================

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = '游꿢';
        b.title = "Ubicar mi posici칩n";
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:18}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// Control de capas
L.control.layers(null, {
    "C칩digo postal": gridLayer,
    "Selecci칩n": selectionLayer,
    "Mi ubicaci칩n": userLocationLayer
}, {collapsed: false}).addTo(mymap);

// Toggle labels
$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    updateGridAndLabels();
});

// Eventos - FORZAR ACTUALIZACI칍N
mymap.on('moveend', updateGridAndLabels);
mymap.on('zoomend', updateGridAndLabels);
mymap.on('zoomstart', () => {
    selectionLayer.clearLayers();
    updateGridAndLabels(); // Actualizar inmediatamente
});

// GPS
mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    
    L.circleMarker(e.latlng, {
        radius: 8,
        color: '#3498db',
        fillColor: '#3498db',
        fillOpacity: 0.7
    }).addTo(userLocationLayer);
    
    // Generar c칩digo para ubicaci칩n
    const code = generatePanamaCode(e.latlng.lat, e.latlng.lng);
    
    const popup = L.popup()
        .setLatLng(e.latlng)
        .setContent(`
            <div style="text-align:center; padding: 10px;">
                <div style="font-weight:bold; margin-bottom: 5px;">游늸 Tu ubicaci칩n</div>
                <div class="code-display" style="font-size: 14px;">${code}</div>
                <div style="font-size: 11px; color: #666; margin-top: 5px;">
                    ${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}
                </div>
            </div>
        `)
        .openOn(mymap);
});

// Inicializar con zoom 10 para ver grid inmediatamente
mymap.setZoom(10);
updateGridAndLabels();
</script>
</body>
</html>
