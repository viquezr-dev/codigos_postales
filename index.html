<!DOCTYPE html>
<html>
<head>
    <title>PanamaCode - Sistema Postal Determin칤stico</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 300px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; font-size: 13px; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 14px; font-weight: bold; }
        .micro-label-fixed { background: none!important; border:none!important; color: #3498db!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 11px; font-weight: bold; }
        .nano-label-fixed { background: none!important; border:none!important; color: #2980b9!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .micro-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-cell { 
            animation: pulse 2s infinite;
            stroke-dasharray: 5, 3;
        }
        @keyframes pulse {
            0% { fill-opacity: 0.3; stroke-width: 3; }
            50% { fill-opacity: 0.6; stroke-width: 4; }
            100% { fill-opacity: 0.3; stroke-width: 3; }
        }
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }
        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        .code-display {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            color: #2c3e50;
            letter-spacing: 1px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 2px solid #3498db;
            margin: 10px 0;
            text-align: center;
        }
        .simple-popup { 
            min-width: 200px;
            margin-bottom: 40px !important; /* Alejar popup de los cuadros */
        }
        .grid-line { pointer-events: none; }
        .grid-region { stroke-dasharray: 10,5; stroke-width: 2.5; }
        .grid-sector { stroke-dasharray: 5,3; stroke-width: 1.5; }
        .grid-cell { stroke-dasharray: 2,2; stroke-width: 1; }
        .popup-offset {
            margin-top: -50px; /* Levantar popup para que no tape */
        }
    </style>
</head>
<body>

<div class="map-title"><h1>PanamaCode - Sistema Postal (13 caracteres)</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: 8A9B-X3Y7-ABC">
    <button id="search-btn">BUSCAR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

<script>
// ==================== CONFIGURACI칍N ====================
const mymap = L.map('mapid').setView([8.50, -80.0], 10);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas SIN CACHE (para evitar problemas)
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let labelsEnabled = true;

// ==================== SISTEMA PanamaCode OPCI칍N A ====================

// Base32 optimizada
const BASE32 = "23456789ABCDEFGHJKMNPQRSTUVWXYZ";
const BASE32_MAP = {};
for (let i = 0; i < BASE32.length; i++) {
    BASE32_MAP[BASE32[i]] = i;
}

// 츼rea de Panam치
const PANAMA_BOUNDS = {
    south: 7.0,
    north: 9.8,
    west: -83.0,
    east: -77.0
};

// Configuraci칩n del sistema 24칑24 micro y 25칑25 nano
const GRID_CONFIG = {
    microSize: 0.02,      // ~2.2km para 24 divisiones
    nanoSize: 0.0008,     // ~90m para 25 divisiones dentro de micro
    regionSize: 0.5       // ~55km para regi칩n
};

// ==================== FUNCIONES DE CODIFICACI칍N DETERMIN칈STICA ====================

// Codificar regi칩n (4 caracteres: AABB)
function encodeRegion(lat, lng) {
    // Calcular posici칩n relativa en Panam치
    const relX = (lng - PANAMA_BOUNDS.west) / (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west);
    const relY = (lat - PANAMA_BOUNDS.south) / (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south);
    
    const safeRelX = Math.max(0.001, Math.min(0.999, relX));
    const safeRelY = Math.max(0.001, Math.min(0.999, relY));
    
    // 8칑8 regiones (64 total)
    const regionX = Math.floor(safeRelX * 8);
    const regionY = Math.floor(safeRelY * 8);
    
    // Codificar en Base32 (2 chars por eje)
    const char1 = BASE32[Math.floor(regionX / 4)];  // 0-1
    const char2 = BASE32[regionX % 4];              // 0-3
    const char3 = BASE32[Math.floor(regionY / 4)];  // 0-1
    const char4 = BASE32[regionY % 4];              // 0-3
    
    return char1 + char2 + char3 + char4;
}

// Codificar micro (4 caracteres: CCDD) - 24칑24
function encodeMicro(lat, lng) {
    const relX = (lng - PANAMA_BOUNDS.west) / (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west);
    const relY = (lat - PANAMA_BOUNDS.south) / (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south);
    
    const safeRelX = Math.max(0.001, Math.min(0.999, relX));
    const safeRelY = Math.max(0.001, Math.min(0.999, relY));
    
    // 칈ndices micro (0-23)
    const microX = Math.floor(safeRelX * 24);
    const microY = Math.floor(safeRelY * 24);
    
    // Codificar: dividir 24 en 3칑8
    const char1 = BASE32[Math.floor(microX / 8)];    // 0-2 (3 valores)
    const char2 = BASE32[microX % 8];               // 0-7
    const char3 = BASE32[Math.floor(microY / 8)];    // 0-2
    const char4 = BASE32[microY % 8];               // 0-7
    
    return char1 + char2 + char3 + char4;
}

// Codificar nano (3 caracteres: EEE) - 25칑25 dentro de micro
function encodeNano(lat, lng) {
    const relX = (lng - PANAMA_BOUNDS.west) / (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west);
    const relY = (lat - PANAMA_BOUNDS.south) / (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south);
    
    const safeRelX = Math.max(0.00001, Math.min(0.99999, relX));
    const safeRelY = Math.max(0.00001, Math.min(0.99999, relY));
    
    // Primero encontrar micro
    const microX = Math.floor(safeRelX * 24);
    const microY = Math.floor(safeRelY * 24);
    
    // Dentro del micro, calcular nano (0-24)
    const nanoX = Math.floor((safeRelX * 24 - microX) * 25);
    const nanoY = Math.floor((safeRelY * 24 - microY) * 25);
    
    // Combinar en un solo n칰mero 0-624 (25칑25)
    const combined = nanoX * 25 + nanoY;
    
    // Codificar en 3 chars Base32 (32췁 = 32768 > 625)
    const char1 = BASE32[Math.floor(combined / 1024)];        // 0-1
    const char2 = BASE32[Math.floor((combined % 1024) / 32)]; // 0-31
    const char3 = BASE32[combined % 32];                      // 0-31
    
    return char1 + char2 + char3;
}

// Generar c칩digo completo (13 caracteres: AABB-CCDD-EEE)
function generatePanamaCode(lat, lng) {
    const regionCode = encodeRegion(lat, lng);    // 4 chars
    const microCode = encodeMicro(lat, lng);      // 4 chars
    const nanoCode = encodeNano(lat, lng);        // 3 chars
    
    return `${regionCode}-${microCode}-${nanoCode}`;
}

// Calcular 칤ndices para visualizaci칩n
function calculateIndices(lat, lng) {
    const relX = (lng - PANAMA_BOUNDS.west) / (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west);
    const relY = (lat - PANAMA_BOUNDS.south) / (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south);
    
    const safeRelX = Math.max(0.00001, Math.min(0.99999, relX));
    const safeRelY = Math.max(0.00001, Math.min(0.99999, relY));
    
    // Micro 칤ndices (0-23)
    const microX = Math.floor(safeRelX * 24);
    const microY = Math.floor(safeRelY * 24);
    
    // Nano 칤ndices dentro de micro (0-24)
    const nanoX = Math.floor((safeRelX * 24 - microX) * 25);
    const nanoY = Math.floor((safeRelY * 24 - microY) * 25);
    
    return {
        microX: Math.min(23, microX),
        microY: Math.min(23, microY),
        nanoX: Math.min(24, nanoX),
        nanoY: Math.min(24, nanoY),
        relX: safeRelX,
        relY: safeRelY
    };
}

// ==================== VISUALIZACI칍N DE GRID ====================

function updateGridAndLabels() {
    gridLayer.clearLayers();
    labelLayer.clearLayers();
    
    const z = mymap.getZoom();
    const bounds = mymap.getBounds();
    
    // Dibujar grid seg칰n zoom
    if (z >= 8) {
        drawGrid(z, bounds);
    }
}

function drawGrid(zoom, bounds) {
    // Grid de regiones (zoom 8-12)
    if (zoom >= 8 && zoom < 13) {
        drawRegionGrid(bounds);
        if (labelsEnabled) drawRegionLabels(bounds);
    }
    
    // Grid de micro (zoom 13-16)
    if (zoom >= 13 && zoom < 17) {
        drawMicroGrid(bounds);
        if (labelsEnabled) drawMicroLabels(bounds);
    }
    
    // Grid de nano (zoom 17+)
    if (zoom >= 17) {
        drawNanoGrid(bounds);
    }
}

function drawRegionGrid(bounds) {
    const startLng = Math.floor(bounds.getWest() / GRID_CONFIG.regionSize) * GRID_CONFIG.regionSize;
    const endLng = Math.ceil(bounds.getEast() / GRID_CONFIG.regionSize) * GRID_CONFIG.regionSize;
    const startLat = Math.floor(bounds.getSouth() / GRID_CONFIG.regionSize) * GRID_CONFIG.regionSize;
    const endLat = Math.ceil(bounds.getNorth() / GRID_CONFIG.regionSize) * GRID_CONFIG.regionSize;
    
    for (let lng = startLng; lng <= endLng; lng += GRID_CONFIG.regionSize) {
        L.polyline([
            [Math.max(bounds.getSouth(), PANAMA_BOUNDS.south), lng],
            [Math.min(bounds.getNorth(), PANAMA_BOUNDS.north), lng]
        ], {
            color: '#1a73e8',
            weight: 2.5,
            opacity: 0.8,
            dashArray: '10,5',
            className: 'grid-line grid-region'
        }).addTo(gridLayer);
    }
    
    for (let lat = startLat; lat <= endLat; lat += GRID_CONFIG.regionSize) {
        L.polyline([
            [lat, Math.max(bounds.getWest(), PANAMA_BOUNDS.west)],
            [lat, Math.min(bounds.getEast(), PANAMA_BOUNDS.east)]
        ], {
            color: '#1a73e8',
            weight: 2.5,
            opacity: 0.8,
            dashArray: '10,5',
            className: 'grid-line grid-region'
        }).addTo(gridLayer);
    }
}

function drawMicroGrid(bounds) {
    const startLng = Math.floor(bounds.getWest() / GRID_CONFIG.microSize) * GRID_CONFIG.microSize;
    const endLng = Math.ceil(bounds.getEast() / GRID_CONFIG.microSize) * GRID_CONFIG.microSize;
    const startLat = Math.floor(bounds.getSouth() / GRID_CONFIG.microSize) * GRID_CONFIG.microSize;
    const endLat = Math.ceil(bounds.getNorth() / GRID_CONFIG.microSize) * GRID_CONFIG.microSize;
    
    // Dibujar cada 2 l칤neas para no saturar
    for (let lng = startLng; lng <= endLng; lng += GRID_CONFIG.microSize * 2) {
        L.polyline([
            [bounds.getSouth(), lng],
            [bounds.getNorth(), lng]
        ], {
            color: '#3498db',
            weight: 1.5,
            opacity: 0.6,
            dashArray: '5,3',
            className: 'grid-line grid-sector'
        }).addTo(gridLayer);
    }
    
    for (let lat = startLat; lat <= endLat; lat += GRID_CONFIG.microSize * 2) {
        L.polyline([
            [lat, bounds.getWest()],
            [lat, bounds.getEast()]
        ], {
            color: '#3498db',
            weight: 1.5,
            opacity: 0.6,
            dashArray: '5,3',
            className: 'grid-line grid-sector'
        }).addTo(gridLayer);
    }
}

function drawNanoGrid(bounds) {
    const startLng = Math.floor(bounds.getWest() / GRID_CONFIG.nanoSize) * GRID_CONFIG.nanoSize;
    const endLng = Math.ceil(bounds.getEast() / GRID_CONFIG.nanoSize) * GRID_CONFIG.nanoSize;
    const startLat = Math.floor(bounds.getSouth() / GRID_CONFIG.nanoSize) * GRID_CONFIG.nanoSize;
    const endLat = Math.ceil(bounds.getNorth() / GRID_CONFIG.nanoSize) * GRID_CONFIG.nanoSize;
    
    // Dibujar cada 10 l칤neas para no saturar
    for (let lng = startLng; lng <= endLng; lng += GRID_CONFIG.nanoSize * 10) {
        L.polyline([
            [bounds.getSouth(), lng],
            [bounds.getNorth(), lng]
        ], {
            color: '#2980b9',
            weight: 1,
            opacity: 0.4,
            dashArray: '2,2',
            className: 'grid-line grid-cell'
        }).addTo(gridLayer);
    }
    
    for (let lat = startLat; lat <= endLat; lat += GRID_CONFIG.nanoSize * 10) {
        L.polyline([
            [lat, bounds.getWest()],
            [lat, bounds.getEast()]
        ], {
            color: '#2980b9',
            weight: 1,
            opacity: 0.4,
            dashArray: '2,2',
            className: 'grid-line grid-cell'
        }).addTo(gridLayer);
    }
}

function drawRegionLabels(bounds) {
    const step = GRID_CONFIG.regionSize;
    
    for (let lng = Math.floor(bounds.getWest() / step) * step; lng <= bounds.getEast(); lng += step) {
        for (let lat = Math.floor(bounds.getSouth() / step) * step; lat <= bounds.getNorth(); lat += step) {
            if (bounds.contains([lat + step/2, lng + step/2])) {
                const regionCode = encodeRegion(lat + step/2, lng + step/2);
                
                L.marker([lat + step/2, lng + step/2], {
                    icon: L.divIcon({ 
                        className: 'watermark-label-fixed', 
                        html: `<div style="background: rgba(255,255,255,0.8); padding: 3px 6px; border-radius: 4px;">${regionCode.substring(0,2)}</div>`, 
                        iconSize: [40, 25] 
                    })
                }).addTo(labelLayer);
            }
        }
    }
}

// ==================== EVENTO CLIC CORREGIDO ====================

mymap.on("click", function (e) {
    selectionLayer.clearLayers();
    
    const lat = e.latlng.lat;
    const lng = e.latlng.lng;
    const z = mymap.getZoom();
    
    // Verificar si est치 dentro de Panam치
    if (lat < PANAMA_BOUNDS.south || lat > PANAMA_BOUNDS.north || 
        lng < PANAMA_BOUNDS.west || lng > PANAMA_BOUNDS.east) {
        showNoCodePopup(e.latlng, "Fuera de Panam치");
        return;
    }
    
    // Calcular 칤ndices EXACTOS
    const indices = calculateIndices(lat, lng);
    
    // Generar c칩digo
    const fullCode = generatePanamaCode(lat, lng);
    const [regionCode, microCode, nanoCode] = fullCode.split('-');
    
    let displayCode = '';
    let titulo = '';
    
    // NIVEL REGI칍N (zoom < 13)
    if (z < 13) {
        titulo = "REGI칍N";
        displayCode = regionCode;
        
        // Calcular bounds de regi칩n
        const regionLng = PANAMA_BOUNDS.west + (indices.relX * (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west));
        const regionLat = PANAMA_BOUNDS.south + (indices.relY * (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south));
        
        const regionBounds = [
            [regionLat - GRID_CONFIG.regionSize/2, regionLng - GRID_CONFIG.regionSize/2],
            [regionLat - GRID_CONFIG.regionSize/2, regionLng + GRID_CONFIG.regionSize/2],
            [regionLat + GRID_CONFIG.regionSize/2, regionLng + GRID_CONFIG.regionSize/2],
            [regionLat + GRID_CONFIG.regionSize/2, regionLng - GRID_CONFIG.regionSize/2]
        ];
        
        L.polygon(regionBounds, {
            color: "#1a73e8",
            weight: 3,
            fillColor: "#1a73e8",
            fillOpacity: 0.3,
            className: 'highlighted-cell'
        }).addTo(selectionLayer);
    }
    
    // NIVEL MICRO (zoom 13-16)
    else if (z >= 13 && z < 17) {
        titulo = "MICRO";
        displayCode = `${regionCode}-${microCode}`;
        
        // Calcular bounds EXACTOS del micro
        const microWest = PANAMA_BOUNDS.west + (indices.microX / 24) * (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west);
        const microEast = PANAMA_BOUNDS.west + ((indices.microX + 1) / 24) * (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west);
        const microSouth = PANAMA_BOUNDS.south + (indices.microY / 24) * (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south);
        const microNorth = PANAMA_BOUNDS.south + ((indices.microY + 1) / 24) * (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south);
        
        const microBounds = [
            [microSouth, microWest],
            [microSouth, microEast],
            [microNorth, microEast],
            [microNorth, microWest]
        ];
        
        L.polygon(microBounds, {
            color: "#3498db",
            weight: 3,
            fillColor: "#3498db",
            fillOpacity: 0.3,
            className: 'highlighted-cell'
        }).addTo(selectionLayer);
    }
    
    // NIVEL NANO (zoom 17+)
    else {
        titulo = "NANO";
        displayCode = fullCode;
        
        // Calcular bounds EXACTOS del nano dentro del micro
        const microWest = PANAMA_BOUNDS.west + (indices.microX / 24) * (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west);
        const microSouth = PANAMA_BOUNDS.south + (indices.microY / 24) * (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south);
        
        const microWidth = (PANAMA_BOUNDS.east - PANAMA_BOUNDS.west) / 24;
        const microHeight = (PANAMA_BOUNDS.north - PANAMA_BOUNDS.south) / 24;
        
        const nanoWidth = microWidth / 25;
        const nanoHeight = microHeight / 25;
        
        const nanoWest = microWest + (indices.nanoX * nanoWidth);
        const nanoEast = nanoWest + nanoWidth;
        const nanoSouth = microSouth + (indices.nanoY * nanoHeight);
        const nanoNorth = nanoSouth + nanoHeight;
        
        const nanoBounds = [
            [nanoSouth, nanoWest],
            [nanoSouth, nanoEast],
            [nanoNorth, nanoEast],
            [nanoNorth, nanoWest]
        ];
        
        L.polygon(nanoBounds, {
            color: "#2980b9",
            weight: 2,
            fillColor: "#2980b9",
            fillOpacity: 0.4,
            className: 'highlighted-cell'
        }).addTo(selectionLayer);
        
        // Borde micro para referencia
        const microBounds = [
            [microSouth, microWest],
            [microSouth, microWest + microWidth],
            [microSouth + microHeight, microWest + microWidth],
            [microSouth + microHeight, microWest]
        ];
        
        L.polygon(microBounds, {
            color: "#3498db",
            weight: 1,
            fillColor: "transparent",
            dashArray: "5,5",
            opacity: 0.5
        }).addTo(selectionLayer);
    }
    
    // Popup ALEJADO de los cuadros
    showSimplePopup(e.latlng, titulo, displayCode);
});

function showSimplePopup(latlng, titulo, codigo) {
    const ws = encodeURIComponent(`游늸 ${codigo}\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`);
    
    // Popup offset para que no tape los cuadros
    const popupOffset = [0, -40];
    
    const popup = L.popup({ 
        offset: popupOffset,
        className: 'simple-popup popup-offset'
    })
    .setLatLng([latlng.lat + 0.0002, latlng.lng]) // Levantar un poco
    .setContent(`
        <div style="text-align:center; padding: 10px;">
            <small>${titulo}</small><br>
            <div class="code-display" style="font-size: 14px;">${codigo}</div>
            <div style="margin-top: 10px;">
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">游늸 MAPS</button>
                <button class="btn-ws" onclick="window.open('https://wa.me/?text=${ws}')">游눫 WS</button>
            </div>
        </div>
    `)
    .openOn(mymap);
    
    popup.on('remove', () => {
        selectionLayer.clearLayers();
    });
}

// ==================== CONTROLES ====================

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = '游꿢';
        b.title = "Ubicar mi posici칩n";
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:18}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// Toggle labels
$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    updateGridAndLabels();
});

// Eventos
mymap.on('moveend zoomend', updateGridAndLabels);
mymap.on('zoomstart', () => selectionLayer.clearLayers());

// Inicializar
updateGridAndLabels();
</script>
</body>
</html>
