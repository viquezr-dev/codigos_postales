<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL DE PANAM√Å</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 250px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .leaflet-top.leaflet-right { top: 80px !important; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; }
        .micro-label-fixed { background: none!important; border:none!important; color: #3498db!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-label-fixed { background: none!important; border:none!important; color: #2980b9!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 8px; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-polygon { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { fill-opacity: 0.3; }
            50% { fill-opacity: 0.7; }
            100% { fill-opacity: 0.3; }
        }
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }
        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        .estafeta-popup .leaflet-popup-content-wrapper {
            background: #d4edda;
            border: 2px solid #28a745;
            border-radius: 8px;
        }
        .estafeta-popup .leaflet-popup-tip {
            background: #28a745;
        }
        .ruta-popup .leaflet-popup-content-wrapper {
            background: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 8px;
        }
        .ruta-popup .leaflet-popup-tip {
            background: #dc3545;
        }
        .zona-popup .leaflet-popup-content-wrapper {
            background: #e9ecef;
            border: 2px solid #6c757d;
            border-radius: 8px;
        }
        .zona-popup .leaflet-popup-tip {
            background: #6c757d;
        }
        .grid-macro { stroke-dasharray: none; }
        .grid-micro { stroke-dasharray: 5, 5; }
        .grid-nano { stroke-dasharray: 2, 3; }
        .nano-popup .leaflet-popup-content-wrapper {
            background: #e3f2fd;
            border: 2px solid #1976d2;
            border-radius: 8px;
            max-width: 350px;
        }
        .nano-popup .leaflet-popup-tip {
            background: #1976d2;
        }
        .codigo-final {
            background: #1976d2;
            color: white;
            padding: 12px 15px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
            text-align: center;
            letter-spacing: 1px;
        }
        .codigo-completo {
            background: #f8f9fa;
            color: #495057;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            margin: 8px 0;
            text-align: center;
            border: 1px solid #dee2e6;
        }
    </style>
</head>
<body>

<div class="map-title"><h1>SISTEMA POSTAL DE PANAM√Å</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: E8399-9G8F6X">
    <button id="search-btn">IR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
// ==============================================
// CONFIGURACI√ìN DEL SISTEMA 0.1¬∞
// ==============================================
const GRID_CONFIG = {
    ORIGIN_LAT: 9.9,      // 9.9¬∞N (norte de Panam√° + margen)
    ORIGIN_LNG: -83.1,    // 83.1¬∞W (oeste de Panam√° + margen)
    RES_MACRO: 0.1,       // 0.1¬∞ ‚âà 11.1 km
    RES_MICRO: 0.1 / 24,  // 0.00416667¬∞ ‚âà 463 m
    RES_NANO: 0.1 / 600,  // 0.000166667¬∞ ‚âà 18.5 m (24√ó25=600)
    ALPHABET: "23456789BCDFGHJKLMNPQRSTVWXYZ", // 30 chars sin ambig√ºedad
    MACROS_X: 60,         // -83.1¬∞ a -77.1¬∞ = 6¬∞ √∑ 0.1 = 60
    MACROS_Y: 27          // 9.9¬∞ a 7.2¬∞ = 2.7¬∞ √∑ 0.1 = 27
};

// Total macros: 60 √ó 27 = 1,620
const TOTAL_MACROS = GRID_CONFIG.MACROS_X * GRID_CONFIG.MACROS_Y;

// ==============================================
// INICIALIZACI√ìN DEL MAPA
// ==============================================
const mymap = L.map('mapid').setView([8.50, -80.0], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas
const zonasGeoLayer = L.layerGroup().addTo(mymap);
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const rutasLayer = L.layerGroup().addTo(mymap);
const estafetasPointsLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawZonas = null;
let rutasData = null, estafetasData = null;
let labelsEnabled = true;
const ALFABETO = "ABCDEFGHJKLMNPQRSTUVWXYZ";

// Cache para watermarks
const microWatermarkCache = new Map();
const nanoWatermarkCache = new Map();
let hiddenLabels = [];

// ==============================================
// FUNCIONES DEL SISTEMA 0.1¬∞
// ==============================================

// 1. Convertir coordenada ‚Üí √≠ndices
function coordenadaAIndices(lat, lng) {
    const { ORIGIN_LAT, ORIGIN_LNG, RES_MACRO, RES_MICRO, RES_NANO } = GRID_CONFIG;
    
    const deltaLng = lng - ORIGIN_LNG;
    const deltaLat = ORIGIN_LAT - lat; // Invertido porque lat disminuye hacia sur
    
    const macroX = Math.max(0, Math.min(GRID_CONFIG.MACROS_X - 1, Math.floor(deltaLng / RES_MACRO)));
    const macroY = Math.max(0, Math.min(GRID_CONFIG.MACROS_Y - 1, Math.floor(deltaLat / RES_MACRO)));
    
    const microX = Math.max(0, Math.min(23, Math.floor((deltaLng % RES_MACRO) / RES_MICRO)));
    const microY = Math.max(0, Math.min(23, Math.floor((deltaLat % RES_MACRO) / RES_MICRO)));
    
    const nanoX = Math.max(0, Math.min(24, Math.floor((((deltaLng % RES_MACRO) % RES_MICRO) / RES_NANO))));
    const nanoY = Math.max(0, Math.min(24, Math.floor((((deltaLat % RES_MACRO) % RES_MICRO) / RES_NANO))));
    
    return { macroX, macroY, microX, microY, nanoX, nanoY };
}

// 2. Convertir n√∫mero a base30 (alfabeto sin ambig√ºedad)
function toBase30(num, digits) {
    const { ALPHABET } = GRID_CONFIG;
    let result = '';
    let n = Math.abs(num);
    
    for (let i = 0; i < digits; i++) {
        result = ALPHABET[n % 30] + result;
        n = Math.floor(n / 30);
    }
    
    return result;
}

// 3. Generar PanamaCode desde coordenada
function generarPanamaCode(lat, lng) {
    const indices = coordenadaAIndices(lat, lng);
    
    // Macro code (2 caracteres): posici√≥n en grid nacional
    const macroNum = indices.macroX * 100 + indices.macroY;
    const macroCode = toBase30(macroNum, 2);
    
    // Micro code (4 caracteres): posici√≥n dentro del macro
    const microNum = indices.microX * 100 + indices.microY;
    const microCode = toBase30(microNum, 4);
    
    // Nano code (2 caracteres): posici√≥n dentro del micro
    const nanoNum = indices.nanoX * 100 + indices.nanoY;
    const nanoCode = toBase30(nanoNum, 2);
    
    // PanamaCode: 8FVC9G8F+6X
    return `${macroCode}${microCode}+${nanoCode}`;
}

// 4. Obtener √∫ltimos 6 d√≠gitos para c√≥digo postal
function obtenerUltimos6Digitos(panamaCode) {
    // De "8FVC9G8F+6X" extraer "9G8F6X"
    // Saltar primeros 2 caracteres (macro) y quitar el "+"
    return panamaCode.substring(2, 8);
}

// 5. Generar c√≥digo postal completo con VM_LEVEL
function generarCodigoPostal(lat, lng, vmLevel) {
    const panamaCode = generarPanamaCode(lat, lng);
    const ultimos6 = obtenerUltimos6Digitos(panamaCode);
    
    return {
        panamaCode: panamaCode,
        codigoPostal: `${vmLevel || 'SINVM'}-${ultimos6}`
    };
}

// 6. Convertir c√≥digo postal a coordenada (b√∫squeda inversa)
function codigoPostalACoordenada(codigoPostal) {
    // Formato: E8399-9G8F6X
    const partes = codigoPostal.split('-');
    if (partes.length !== 2) return null;
    
    const vmLevel = partes[0];
    const ultimos6 = partes[1];
    
    if (ultimos6.length !== 6) return null;
    
    // Reconstruir PanamaCode parcial (necesitamos macro+micro completo)
    // Esto es simplificado - para b√∫squeda precisa necesitar√≠amos base de datos
    const microCode = ultimos6.substring(0, 4); // 9G8F
    const nanoCode = ultimos6.substring(4, 6);   // 6X
    
    // Para demo: usar coordenada aproximada del centro de Panam√°
    return {
        lat: 8.5,
        lng: -80.0,
        vmLevel: vmLevel,
        microCode: microCode,
        nanoCode: nanoCode
    };
}

// ==============================================
// FUNCIONES AUXILIARES
// ==============================================

// Obtener VM_LEVEL desde pol√≠gono
function obtenerVMLEVEL(latlng) {
    if (!rawZonas) return null;
    
    const punto = [latlng.lng, latlng.lat];
    const zonasEnPunto = leafletPip.pointInLayer(punto, L.geoJSON(rawZonas));
    
    if (zonasEnPunto.length > 0) {
        return zonasEnPunto[0].feature.properties.VM_LEVEL;
    }
    
    return null;
}

// Restaurar labels ocultos
function restoreHiddenLabels() {
    hiddenLabels.forEach(layer => {
        if (layer && typeof layer.setOpacity === 'function') {
            layer.setOpacity(1);
        }
    });
    hiddenLabels = [];
}

// ==============================================
// DIBUJAR GRID F√çSICO 0.1¬∞
// ==============================================

function dibujarGridFisico() {
    gridLayer.clearLayers();
    const z = mymap.getZoom();
    
    if (z < 10) return; // Solo mostrar en zoom alto
    
    const { ORIGIN_LAT, ORIGIN_LNG, RES_MACRO, RES_MICRO, RES_NANO } = GRID_CONFIG;
    const bounds = mymap.getBounds();
    
    // Dibujar macros visibles
    for (let mx = 0; mx < GRID_CONFIG.MACROS_X; mx++) {
        for (let my = 0; my < GRID_CONFIG.MACROS_Y; my++) {
            const lat1 = ORIGIN_LAT - (my * RES_MACRO);
            const lng1 = ORIGIN_LNG + (mx * RES_MACRO);
            const lat2 = lat1 - RES_MACRO;
            const lng2 = lng1 + RES_MACRO;
            
            const macroBounds = L.latLngBounds([lat1, lng1], [lat2, lng2]);
            
            if (!bounds.intersects(macroBounds)) continue;
            
            // Dibujar borde macro
            L.rectangle([[lat1, lng1], [lat2, lng2]], {
                color: '#1a73e8',
                weight: z >= 14 ? 2 : 1,
                fillOpacity: 0,
                className: 'grid-macro'
            }).addTo(gridLayer);
            
            // Etiqueta macro
            if (z >= 10 && z < 14 && labelsEnabled) {
                const centro = [(lat1 + lat2) / 2, (lng1 + lng2) / 2];
                const macroNum = mx * 100 + my;
                const macroCode = toBase30(macroNum, 2);
                
                L.marker(centro, {
                    icon: L.divIcon({
                        className: 'watermark-label-fixed',
                        html: macroCode,
                        iconSize: [40, 20]
                    })
                }).addTo(labelLayer);
            }
            
            // Dibujar micros si zoom alto
            if (z >= 14) {
                for (let ux = 0; ux < 24; ux++) {
                    for (let uy = 0; uy < 24; uy++) {
                        const mlat1 = lat1 - (uy * RES_MICRO);
                        const mlng1 = lng1 + (ux * RES_MICRO);
                        const mlat2 = mlat1 - RES_MICRO;
                        const mlng2 = mlng1 + RES_MICRO;
                        
                        const microBounds = L.latLngBounds([mlat1, mlng1], [mlat2, mlng2]);
                        if (!bounds.intersects(microBounds)) continue;
                        
                        // Guardar en cache para clics
                        const cacheKey = `m${mx}-${my}-${ux}-${uy}`;
                        microWatermarkCache.set(cacheKey, {
                            bounds: [[mlat1, mlng1], [mlat2, mlng2]],
                            center: [(mlat1 + mlat2) / 2, (mlng1 + mlng2) / 2],
                            indices: { mx, my, ux, uy }
                        });
                        
                        // Dibujar borde micro
                        if (z >= 14 && z < 17) {
                            L.rectangle([[mlat1, mlng1], [mlat2, mlng2]], {
                                color: '#3498db',
                                weight: 0.5,
                                fillOpacity: 0,
                                dashArray: '5,5',
                                className: 'grid-micro'
                            }).addTo(gridLayer);
                            
                            // Etiqueta micro
                            if (labelsEnabled && ux % 6 === 0 && uy % 6 === 0) {
                                const microNum = ux * 100 + uy;
                                const microCode = toBase30(microNum, 4);
                                
                                L.marker([(mlat1 + mlat2) / 2, (mlng1 + mlng2) / 2], {
                                    icon: L.divIcon({
                                        className: 'micro-label-fixed',
                                        html: microCode.substring(2, 4), // Mostrar solo 2 chars
                                        iconSize: [30, 15]
                                    })
                                }).addTo(labelLayer);
                            }
                        }
                        
                        // Dibujar nanos si zoom muy alto
                        if (z >= 17) {
                            for (let nx = 0; nx < 25; nx++) {
                                for (let ny = 0; ny < 25; ny++) {
                                    const nlat1 = mlat1 - (ny * RES_NANO);
                                    const nlng1 = mlng1 + (nx * RES_NANO);
                                    const nlat2 = nlat1 - RES_NANO;
                                    const nlng2 = nlng1 + RES_NANO;
                                    
                                    const nanoCenter = [(nlat1 + nlat2) / 2, (nlng1 + nlng2) / 2];
                                    if (!bounds.contains(nanoCenter)) continue;
                                    
                                    // Guardar en cache
                                    const nanoKey = `m${mx}-${my}-${ux}-${uy}-${nx}-${ny}`;
                                    nanoWatermarkCache.set(nanoKey, {
                                        bounds: [[nlat1, nlng1], [nlat2, nlng2]],
                                        center: nanoCenter,
                                        indices: { mx, my, ux, uy, nx, ny }
                                    });
                                    
                                    // Etiqueta nano (solo algunas)
                                    if (labelsEnabled && nx % 5 === 0 && ny % 5 === 0) {
                                        const nanoNum = nx * 100 + ny;
                                        const nanoCode = toBase30(nanoNum, 2);
                                        
                                        L.marker(nanoCenter, {
                                            icon: L.divIcon({
                                                className: 'nano-label-fixed',
                                                html: nanoCode,
                                                iconSize: [25, 10]
                                            })
                                        }).addTo(labelLayer);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// ==============================================
// CARGAR DATOS EXISTENTES
// ==============================================

$.getJSON("estafetas.geojson", d => { 
    rawZonas = d; 
    L.geoJSON(d, {
        style: {color: "#2c3e50", weight: 1.5, fillOpacity: 0.05},
        onEachFeature: function(feature, layer) {
            layer.on('click', function(e) {
                mostrarPopupZona(e.latlng, feature);
                L.DomEvent.stopPropagation(e);
            });
        }
    }).addTo(zonasGeoLayer); 
});

$.getJSON("estafetasl.geojson", d => { 
    rutasData = d;
    L.geoJSON(d, {
        style: function(feature) {
            return {
                color: "#e74c3c", 
                weight: 4,
                opacity: 0.8
            };
        },
        onEachFeature: function(feature, layer) {
            layer.on('click', function(e) {
                mostrarPopupRuta(e.latlng, feature);
                L.DomEvent.stopPropagation(e);
            });
        }
    }).addTo(rutasLayer);
});

$.getJSON("estafetasp.geojson", d => { 
    estafetasData = d;
    L.geoJSON(d, {
        pointToLayer: (f, ll) => L.circleMarker(ll, {
            radius: 8,
            color: "#27ae60", 
            fillColor: "#2ecc71", 
            fillOpacity: 0.9,
            weight: 3
        }),
        onEachFeature: function(feature, layer) {
            layer.on('click', function(e) {
                mostrarPopupEstafeta(e.latlng, feature);
                L.DomEvent.stopPropagation(e);
            });
        }
    }).addTo(estafetasPointsLayer);
});

// ==============================================
// EVENTO CLIC PRINCIPAL
// ==============================================

mymap.on("click", function (e) {
    console.log("Clic en:", e.latlng.lat.toFixed(6), e.latlng.lng.toFixed(6));
    
    // Limpiar selecci√≥n anterior
    selectionLayer.clearLayers();
    restoreHiddenLabels();
    hiddenLabels = [];
    
    // PRIMERO: Verificar si se hizo clic en una estafeta
    const estafetaClic = verificarClicEnEstafetas(e.latlng);
    if (estafetaClic) {
        mostrarPopupEstafeta(e.latlng, estafetaClic);
        return;
    }
    
    // SEGUNDO: Verificar si se hizo clic en una ruta
    const rutaClic = verificarClicEnRutas(e.latlng);
    if (rutaClic) {
        mostrarPopupRuta(e.latlng, rutaClic);
        return;
    }
    
    // TERCERO: Verificar si se hizo clic en una zona
    const zonaClic = verificarClicEnZonas(e.latlng);
    if (zonaClic) {
        mostrarPopupZona(e.latlng, zonaClic);
        return;
    }
    
    // CUARTO: Generar c√≥digo postal (nuevo sistema 0.1¬∞)
    const vmLevel = obtenerVMLEVEL(e.latlng) || 'SINVM';
    const codigos = generarCodigoPostal(e.latlng.lat, e.latlng.lng, vmLevel);
    
    // Resaltar celda nano
    const indices = coordenadaAIndices(e.latlng.lat, e.latlng.lng);
    const { ORIGIN_LAT, ORIGIN_LNG, RES_MICRO, RES_NANO } = GRID_CONFIG;
    
    const lat1 = ORIGIN_LAT - (indices.macroY * GRID_CONFIG.RES_MACRO) - (indices.microY * RES_MICRO) - (indices.nanoY * RES_NANO);
    const lng1 = ORIGIN_LNG + (indices.macroX * GRID_CONFIG.RES_MACRO) + (indices.microX * RES_MICRO) + (indices.nanoX * RES_NANO);
    const lat2 = lat1 - RES_NANO;
    const lng2 = lng1 + RES_NANO;
    
    L.rectangle([[lat1, lng1], [lat2, lng2]], {
        color: '#2980b9',
        weight: 3,
        fillColor: '#2980b9',
        fillOpacity: 0.5,
        className: 'highlighted-polygon'
    }).addTo(selectionLayer);
    
    // Mostrar popup con c√≥digo postal
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(e.latlng.lat + 0.0004, e.latlng.lng);
    
    const popup = L.popup({offset: popupOffset, className: 'nano-popup'})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center; padding: 15px; max-width: 350px;">
                <div style="font-size: 16px; color: #1976d2; margin-bottom: 10px; font-weight: bold;">
                    üìç C√ìDIGO POSTAL
                </div>
                
                <div class="codigo-completo">
                    <strong>PanamaCode:</strong> ${codigos.panamaCode}
                </div>
                
                <div style="font-size: 11px; color: #666; margin-bottom: 15px; text-align: center; font-style: italic;">
                    CODIGO POSTAL: (marcado en un globo para que se vea mejor)
                </div>
                
                <div class="codigo-final">
                    ${codigos.codigoPostal}
                </div>
                
                <div style="font-size: 12px; color: #495057; margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                    GPS: ${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${e.latlng.lat},${e.latlng.lng}')">üìç MAPS</button>
                    <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç C√≥digo Postal: ${codigos.codigoPostal}\nPanamaCode: ${codigos.panamaCode}\nGPS: ${e.latlng.lat.toFixed(6)},${e.latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
        restoreHiddenLabels();
    });
});

// ==============================================
// FUNCIONES DE DETECCI√ìN (mantener existentes)
// ==============================================

function verificarClicEnZonas(latlng) {
    if (!rawZonas || !mymap.hasLayer(zonasGeoLayer)) return null;
    const punto = [latlng.lng, latlng.lat];
    const zonasEnPunto = leafletPip.pointInLayer(punto, L.geoJSON(rawZonas));
    return zonasEnPunto.length > 0 ? zonasEnPunto[0].feature : null;
}

function verificarClicEnEstafetas(latlng) {
    if (!estafetasData || !mymap.hasLayer(estafetasPointsLayer)) return null;
    let estafetaMasCercana = null;
    let distanciaMinima = Infinity;
    const TOLERANCIA_METROS = 15;
    const toleranceDegrees = TOLERANCIA_METROS / 111000;
    
    estafetasData.features.forEach(feature => {
        if (feature.geometry.type === 'Point') {
            const puntoEstafeta = {
                lat: feature.geometry.coordinates[1],
                lng: feature.geometry.coordinates[0]
            };
            const dx = latlng.lng - puntoEstafeta.lng;
            const dy = latlng.lat - puntoEstafeta.lat;
            const distancia = Math.sqrt(dx * dx + dy * dy);
            
            if (distancia < distanciaMinima && distancia < toleranceDegrees) {
                distanciaMinima = distancia;
                estafetaMasCercana = feature;
            }
        }
    });
    
    return estafetaMasCercana;
}

function verificarClicEnRutas(latlng) {
    if (!rutasData || !mymap.hasLayer(rutasLayer)) return null;
    let rutaMasCercana = null;
    let distanciaMinima = Infinity;
    const TOLERANCIA_METROS = 10;
    const toleranceDegrees = TOLERANCIA_METROS / 111000;
    
    rutasData.features.forEach(feature => {
        if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {
            let coordinates = [];
            if (feature.geometry.type === 'LineString') {
                coordinates = feature.geometry.coordinates;
            } else if (feature.geometry.type === 'MultiLineString') {
                feature.geometry.coordinates.forEach(line => {
                    coordinates = coordinates.concat(line);
                });
            }
            
            for (let i = 0; i < coordinates.length - 1; i++) {
                const p1 = { lng: coordinates[i][0], lat: coordinates[i][1] };
                const p2 = { lng: coordinates[i + 1][0], lat: coordinates[i + 1][1] };
                const distancia = distanciaPuntoASegmento(latlng, p1, p2);
                
                if (distancia < distanciaMinima && distancia < toleranceDegrees) {
                    distanciaMinima = distancia;
                    rutaMasCercana = feature;
                }
            }
        }
    });
    
    return rutaMasCercana;
}

function distanciaPuntoASegmento(p, a, b) {
    const A = p.lng - a.lng;
    const B = p.lat - a.lat;
    const C = b.lng - a.lng;
    const D = b.lat - a.lat;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    
    if (lenSq === 0) {
        const dx = p.lng - a.lng;
        const dy = p.lat - a.lat;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    let param = dot / lenSq;
    let xx, yy;
    
    if (param < 0) {
        xx = a.lng;
        yy = a.lat;
    } else if (param > 1) {
        xx = b.lng;
        yy = b.lat;
    } else {
        xx = a.lng + param * C;
        yy = a.lat + param * D;
    }
    
    const dx = p.lng - xx;
    const dy = p.lat - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

// ==============================================
// POPUPS (mantener existentes)
// ==============================================

function mostrarPopupZona(latlng, zona) {
    const p = zona.properties || {};
    const nivelVM = p.VM_LEVEL || "N/A";
    const nombre = p.nombre || p.name || `Zona ${nivelVM}`;
    const fid = p.fid !== undefined ? p.fid : "N/A";
    
    const popup = L.popup({className: 'zona-popup'})
        .setLatLng(latlng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 280px;">
                <div style="font-size: 16px; color: #6c757d; margin-bottom: 8px; font-weight: bold;">
                    üó∫Ô∏è ${nombre}
                </div>
                <div style="font-size: 12px; color: #495057; margin-bottom: 12px; text-align: left; line-height: 1.4;">
                    <strong>Nivel VM:</strong> ${nivelVM}<br>
                    <strong>ID:</strong> ${fid}
                </div>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
            </div>
        `)
        .openOn(mymap);
    
    selectionLayer.clearLayers();
    L.geoJSON(zona, {
        style: {
            color: "#6c757d", 
            weight: 4, 
            fillColor: "#6c757d",
            fillOpacity: 0.3,
            className: 'highlighted-polygon'
        }
    }).addTo(selectionLayer);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
    });
}

function mostrarPopupEstafeta(latlng, estafeta) {
    const p = estafeta.properties || {};
    const nombre = p.ESTAF_NAME || p.nombre || p.name || "Estafeta Postal";
    const codigo = p.ESTAF_CODE || p.codigo || p.id || "N/A";
    const ruta = p.RUTA || "N/A";
    const nivel = p.VM_LEVEL || "N/A";
    
    const popup = L.popup({className: 'estafeta-popup'})
        .setLatLng(latlng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 280px;">
                <div style="font-size: 16px; color: #28a745; margin-bottom: 8px; font-weight: bold;">
                    üìÆ ${nombre}
                </div>
                <div style="font-size: 12px; color: #155724; margin-bottom: 12px; text-align: left; line-height: 1.4;">
                    <strong>C√≥digo:</strong> ${codigo}<br>
                    <strong>Ruta:</strong> ${ruta}<br>
                    <strong>Nivel VM:</strong> ${nivel}
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                    <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç Estafeta: ${nombre}\nC√≥digo: ${codigo}\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
    
    selectionLayer.clearLayers();
    L.circleMarker(latlng, {
        radius: 10,
        color: "#28a745",
        fillColor: "#28a745",
        fillOpacity: 0.9,
        weight: 3
    }).addTo(selectionLayer);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
    });
}

function mostrarPopupRuta(latlng, ruta) {
    const p = ruta.properties || {};
    const rutaNombre = p.RUTA || p.nombre || p.name || "Ruta Postal";
    const tramo = p.tramo !== undefined ? p.tramo : "N/A";
    
    const popup = L.popup({className: 'ruta-popup'})
        .setLatLng(latlng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 280px;">
                <div style="font-size: 16px; color: #dc3545; margin-bottom: 8px; font-weight: bold;">
                    üöö Ruta: ${rutaNombre}
                </div>
                <div style="font-size: 12px; color: #721c24; margin-bottom: 12px; text-align: left; line-height: 1.4;">
                    <strong>Tramo:</strong> ${tramo}<br>
                    <strong>Coordenadas:</strong> ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                    <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç Ruta: ${rutaNombre}\nTramo: ${tramo}\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
    
    selectionLayer.clearLayers();
    L.circleMarker(latlng, {
        radius: 6,
        color: "#dc3545",
        fillColor: "#dc3545",
        fillOpacity: 0.8,
        weight: 3
    }).addTo(selectionLayer);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
    });
}

// ==============================================
// BUSCADOR
// ==============================================

document.getElementById('search-btn').addEventListener('click', () => {
    const input = document.getElementById('search-input').value.trim().toUpperCase();
    
    if (!input) return;
    
    // Si es c√≥digo postal (E8399-9G8F6X)
    if (input.includes('-') && input.split('-')[1].length === 6) {
        const coord = codigoPostalACoordenada(input);
        
        if (coord) {
            mymap.setView([coord.lat, coord.lng], 18);
            
            selectionLayer.clearLayers();
            L.circleMarker([coord.lat, coord.lng], {
                radius: 10,
                color: '#1976d2',
                fillColor: '#1976d2',
                fillOpacity: 0.8
            }).addTo(selectionLayer);
            
            // Generar c√≥digo para mostrar
            const vmLevel = input.split('-')[0];
            const codigos = generarCodigoPostal(coord.lat, coord.lng, vmLevel);
            
            L.popup()
                .setLatLng([coord.lat, coord.lng])
                .setContent(`
                    <div style="text-align:center; padding: 10px;">
                        <div style="font-size: 14px; color: #1976d2; margin-bottom: 5px; font-weight: bold;">
                            üìç ${input}
                        </div>
                        <div style="font-size: 11px; color: #666;">
                            ${codigos.panamaCode}<br>
                            ${coord.lat.toFixed(6)}, ${coord.lng.toFixed(6)}
                        </div>
                    </div>
                `)
                .openOn(mymap);
        } else {
            alert("C√≥digo postal no encontrado: " + input);
        }
    } else {
        // B√∫squeda por nombre o coordenadas
        alert("Formato no reconocido. Usa: E8399-9G8F6X");
    }
});

// ==============================================
// CONTROLES Y EVENTOS
// ==============================================

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = 'üéØ';
        b.title = "Ubicar mi posici√≥n";
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:18}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// Control de capas
L.control.layers(null, {
    "Zonas (Referencia)": zonasGeoLayer,
    "Rutas": rutasLayer,
    "Estafetas": estafetasPointsLayer,
    "Cuadr√≠cula Postal": gridLayer,
    "Selecci√≥n": selectionLayer,
    "Mi ubicaci√≥n": userLocationLayer
}, {collapsed: false}).addTo(mymap);

// Toggle labels
$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    dibujarGridFisico();
});

// Eventos del mapa
mymap.on('moveend zoomend', dibujarGridFisico);
mymap.on('zoomstart movestart', function() {
    selectionLayer.clearLayers();
    restoreHiddenLabels();
});

// Ubicaci√≥n del usuario
mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    L.marker(e.latlng, {
        icon: L.divIcon({
            className: 'user-location-icon',
            html: 'üìç',
            iconSize: [30, 30]
        }),
        zIndexOffset: 1000
    }).addTo(userLocationLayer);
    
    L.circle(e.latlng, {
        radius: e.accuracy / 2,
        color: '#3498db',
        fillColor: '#3498db',
        fillOpacity: 0.1,
        weight: 1
    }).addTo(userLocationLayer);
});

mymap.on('locationerror', function(e) {
    console.error("Error de ubicaci√≥n:", e.message);
});

// ==============================================
// INICIALIZACI√ìN
// ==============================================

// Dibujar grid inicial
setTimeout(() => {
    dibujarGridFisico();
}, 1000);

console.log("‚úÖ Sistema Postal 0.1¬∞ cargado correctamente");
console.log("Configuraci√≥n:", GRID_CONFIG);
console.log("Total macros:", TOTAL_MACROS);
</script>
</body>
</html>
