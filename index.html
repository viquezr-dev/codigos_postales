<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL DE PANAM츼 - POL칈GONOS IRREGULARES</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 300px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .leaflet-top.leaflet-right { top: 80px !important; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; }
        .micro-label-fixed { background: none!important; border:none!important; color: #3498db!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-label-fixed { background: none!important; border:none!important; color: #2980b9!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 8px; }
        .nano-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .micro-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-polygon { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { fill-opacity: 0.3; }
            50% { fill-opacity: 0.7; }
            100% { fill-opacity: 0.3; }
        }
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }
        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        .polygon-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            padding: 5px;
            background: #f8f9fa;
            border-radius: 3px;
            border-left: 3px solid #3498db;
        }
    </style>
</head>
<body>

<div class="map-title"><h1>SISTEMA POSTAL DE PANAM츼 - POL칈GONOS IRREGULARES</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: HERRERA-K4299-KF952-J31">
    <button id="search-btn">BUSCAR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
const mymap = L.map('mapid').setView([8.0, -80.5], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas
const zonasGeoLayer = L.layerGroup().addTo(mymap);
const cuadriculaFisicaLayer = L.layerGroup().addTo(mymap);
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawZonas = null;
let labelsEnabled = true;
const ALFABETO = "ABCDEFGHJKLMNPQRSTUVWXYZ";
const NANO_RES = 25;

// CACHE
const microWatermarkCache = new Map();
const nanoWatermarkCache = new Map();
let hiddenLabels = [];

// ==================== FUNCIONES AUXILIARES ====================

function generarCodigoMacro(provincia, vmLevel, fid) {
    // Usar provincia + VM_LEVEL + fid para unicidad
    const provCode = provincia.substring(0, 3).toUpperCase();
    return `${provCode}-${vmLevel}`;
}

function getMicroCodeFromIndices(ix, iy, fid, vmLevel) {
    const baseCode = `${ALFABETO[ix]}${ALFABETO[iy]}${ix % 10}${iy % 10}`;
    const factor = (Math.floor((ix + iy) / 5) + (fid % 10) + (vmLevel.charCodeAt(0) % 10)) % 10;
    return baseCode + factor;
}

function generateNanoCode(nix, niy, microIx, microIy, fid, vmLevel) {
    const salt = (microIx * 24 + microIy) * 1000 + fid + (vmLevel.charCodeAt(0) * 100);
    let hash = (nix * 15485863) ^ (niy * 2860486313) ^ (salt * 5915587277);
    hash = (hash * 2654435761) >>> 0;
    
    const letterIndex = (hash % 24);
    const num1 = Math.floor((hash / 24) % 10);
    const num2 = Math.floor((hash / 240) % 10);
    
    return `${ALFABETO[letterIndex]}${num1}${num2}`;
}

function pointInPolygon(point, feature) {
    return leafletPip.pointInLayer(point, L.geoJSON(feature)).length > 0;
}

function getPointInBoundingBox(bounds, relX, relY) {
    const lat = bounds.getSouth() + relY * (bounds.getNorth() - bounds.getSouth());
    const lng = bounds.getWest() + relX * (bounds.getEast() - bounds.getWest());
    return [lat, lng];
}

function findClosestWatermark(clickLatLng, watermarkCache, maxDistance = 0.001) {
    let closestWatermark = null;
    let minDistance = Infinity;
    
    watermarkCache.forEach((watermark, key) => {
        const dx = clickLatLng.lng - watermark.center[1];
        const dy = clickLatLng.lat - watermark.center[0];
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance < minDistance && distance < maxDistance) {
            minDistance = distance;
            closestWatermark = watermark;
        }
    });
    
    return closestWatermark;
}

function restoreHiddenLabels() {
    hiddenLabels.forEach(layer => {
        if (layer && typeof layer.setOpacity === 'function') {
            layer.setOpacity(1);
        }
    });
    hiddenLabels = [];
}

// ==================== CARGA Y PROCESAMIENTO ====================

function procesarZonas(data) {
    // A침adir propiedades calculadas a cada feature
    data.features.forEach(feature => {
        const props = feature.properties;
        props.codigo = generarCodigoMacro(props.PROV_NOMB, props.VM_LEVEL, props.fid);
        props.color = props.fid % 2 === 0 ? '#2c3e50' : '#34495e';
        props.area_km2 = (props.AREA / 1000000).toFixed(2);
    });
    return data;
}

function updateGridAndLabels() {
    gridLayer.clearLayers();
    labelLayer.clearLayers();
    microWatermarkCache.clear();
    nanoWatermarkCache.clear();
    hiddenLabels = [];
    
    if (!rawZonas) return;
    
    const z = mymap.getZoom();
    const bounds = mymap.getBounds();

    rawZonas.features.forEach((feature) => {
        const featureBounds = L.geoJSON(feature).getBounds();
        if (!bounds.intersects(featureBounds)) return;
        
        const macroCode = feature.properties.codigo;
        const fid = feature.properties.fid;
        const vmLevel = feature.properties.VM_LEVEL || '';
        
        // Labels macro (zoom 9-14)
        if (z >= 9 && z < 14 && labelsEnabled) {
            const center = featureBounds.getCenter();
            if (pointInPolygon([center.lng, center.lat], feature)) {
                L.marker(center, {
                    icon: L.divIcon({ 
                        className: 'watermark-label-fixed', 
                        html: macroCode, 
                        iconSize: [80, 25] 
                    })
                }).addTo(labelLayer);
            }
        }
        
        // Generar celdas micro (24x24 dentro del bounding box)
        for (let i = 0; i < 24; i++) {
            for (let j = 0; j < 24; j++) {
                const microCenter = getPointInBoundingBox(
                    featureBounds, 
                    (i + 0.5) / 24, 
                    (j + 0.5) / 24
                );
                
                if (pointInPolygon([microCenter[1], microCenter[0]], feature)) {
                    const microCode = getMicroCodeFromIndices(i, j, fid, vmLevel);
                    
                    // Calcular bounds de la celda micro
                    const microBounds = [
                        getPointInBoundingBox(featureBounds, i/24, j/24),
                        getPointInBoundingBox(featureBounds, (i+1)/24, j/24),
                        getPointInBoundingBox(featureBounds, (i+1)/24, (j+1)/24),
                        getPointInBoundingBox(featureBounds, i/24, (j+1)/24)
                    ];
                    
                    // Guardar en cache
                    const cacheKey = `f${fid}-micro-${i}-${j}`;
                    microWatermarkCache.set(cacheKey, {
                        center: microCenter,
                        code: microCode,
                        bounds: microBounds,
                        feature: feature,
                        indices: { ix: i, iy: j, fid: fid }
                    });
                    
                    // Labels micro (zoom 14-17)
                    if (z >= 14 && z < 17 && labelsEnabled) {
                        L.marker(microCenter, {
                            icon: L.divIcon({ 
                                className: 'micro-label-fixed', 
                                html: microCode, 
                                iconSize: [50, 18] 
                            })
                        }).addTo(labelLayer);
                    }
                    
                    // Generar celdas nano (25x25 dentro de cada micro)
                    if (z >= 17) {
                        for (let ni = 0; ni < NANO_RES; ni++) {
                            for (let nj = 0; nj < NANO_RES; nj++) {
                                const nanoCenter = getPointInBoundingBox(
                                    featureBounds,
                                    (i + (ni + 0.5)/NANO_RES) / 24,
                                    (j + (nj + 0.5)/NANO_RES) / 24
                                );
                                
                                if (pointInPolygon([nanoCenter[1], nanoCenter[0]], feature)) {
                                    const nanoCode = generateNanoCode(ni, nj, i, j, fid, vmLevel);
                                    
                                    const nanoBounds = [
                                        getPointInBoundingBox(featureBounds, (i + ni/NANO_RES)/24, (j + nj/NANO_RES)/24),
                                        getPointInBoundingBox(featureBounds, (i + (ni+1)/NANO_RES)/24, (j + nj/NANO_RES)/24),
                                        getPointInBoundingBox(featureBounds, (i + (ni+1)/NANO_RES)/24, (j + (nj+1)/NANO_RES)/24),
                                        getPointInBoundingBox(featureBounds, (i + ni/NANO_RES)/24, (j + (nj+1)/NANO_RES)/24)
                                    ];
                                    
                                    const nanoKey = `f${fid}-nano-${i}-${j}-${ni}-${nj}`;
                                    nanoWatermarkCache.set(nanoKey, {
                                        center: nanoCenter,
                                        code: nanoCode,
                                        bounds: nanoBounds,
                                        feature: feature,
                                        indices: { microIx: i, microIy: j, nix: ni, niy: nj, fid: fid }
                                    });
                                    
                                    // Labels nano selectivos
                                    if (labelsEnabled && ni % 5 === 0 && nj % 5 === 0) {
                                        L.marker(nanoCenter, {
                                            icon: L.divIcon({ 
                                                className: 'nano-label-fixed', 
                                                html: nanoCode, 
                                                iconSize: [40, 12] 
                                            })
                                        }).addTo(labelLayer);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Dibujar rejilla
        if (z >= 14 && mymap.hasLayer(gridLayer)) {
            for (let i = 0; i <= 24; i++) {
                // Verticales
                const vStart = getPointInBoundingBox(featureBounds, i/24, 0);
                const vEnd = getPointInBoundingBox(featureBounds, i/24, 1);
                
                // Horizontales
                const hStart = getPointInBoundingBox(featureBounds, 0, i/24);
                const hEnd = getPointInBoundingBox(featureBounds, 1, i/24);
                
                let weight, opacity, color;
                if (z >= 14 && z < 17) {
                    weight = 1.5;
                    opacity = 0.6;
                    color = '#2980b9';
                } else {
                    weight = 1.0;
                    opacity = 0.5;
                    color = '#3498db';
                }
                
                if (pointInPolygon([vStart[1], vStart[0]], feature) || 
                    pointInPolygon([vEnd[1], vEnd[0]], feature)) {
                    L.polyline([vStart, vEnd], {color: color, weight: weight, opacity: opacity}).addTo(gridLayer);
                }
                
                if (pointInPolygon([hStart[1], hStart[0]], feature) || 
                    pointInPolygon([hEnd[1], hEnd[0]], feature)) {
                    L.polyline([hStart, hEnd], {color: color, weight: weight, opacity: opacity}).addTo(gridLayer);
                }
            }
        }
    });
}

// ==================== EVENTOS ====================

// Cargar datos
$.getJSON("estafetas.geojson", d => { 
    rawZonas = procesarZonas(d); 
    
    // A침adir pol칤gonos con colores diferenciados
    L.geoJSON(rawZonas, {
        style: function(feature) {
            return {
                color: feature.properties.color,
                weight: 1.5,
                fillOpacity: 0.05,
                opacity: 0.8
            };
        },
        onEachFeature: function(feature, layer) {
            const props = feature.properties;
            layer.bindPopup(`
                <b>${props.codigo}</b><br>
                Provincia: ${props.PROV_NOMB}<br>
                VM Level: ${props.VM_LEVEL}<br>
                츼rea: ${props.area_km2} km<br>
                Estafeta: ${props.ESTAF_NAME}
            `);
        }
    }).addTo(zonasGeoLayer);
    
    updateGridAndLabels();
});

// Evento clic
mymap.on("click", function (e) {
    selectionLayer.clearLayers();
    restoreHiddenLabels();
    
    if (!rawZonas) return;
    
    const clickedFeatures = leafletPip.pointInLayer(
        [e.latlng.lng, e.latlng.lat], 
        L.geoJSON(rawZonas)
    );

    // Verificar si est치 en 치rea no definida
    if (clickedFeatures.length === 0) {
        const popupOffset = [0, -60];
        const popupLatLng = L.latLng(e.latlng.lat + 0.0004, e.latlng.lng);
        
        L.popup({offset: popupOffset, className: 'warning-popup'})
            .setLatLng(popupLatLng)
            .setContent(`
                <div style="text-align:center; padding: 10px;">
                    <div style="font-size: 16px; color: #e74c3c; margin-bottom: 5px;">
                        丘멆잺 츼REA NO DEFINIDA
                    </div>
                    <div style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">
                        Esta ubicaci칩n est치 fuera de las zonas postales
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${e.latlng.lat},${e.latlng.lng}')">游늸 MAPS</button>
                        <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`游늸 Ubicaci칩n fuera del sistema postal\nGPS: ${e.latlng.lat.toFixed(6)},${e.latlng.lng.toFixed(6)}`)}')">游눫 WS</button>
                    </div>
                </div>
            `)
            .openOn(mymap);
        return;
    }

    const feature = clickedFeatures[0].feature;
    const props = feature.properties;
    const macroCode = props.codigo;
    const fid = props.fid;
    
    let titulo = "ZONA POSTAL";
    let finalCode = macroCode;
    const z = mymap.getZoom();

    if (z < 14) {
        // Nivel macro
        titulo = "ZONA POSTAL";
        L.geoJSON(feature, {
            style: {
                color: "#1a73e8", 
                weight: 4, 
                fillColor: "#1a73e8",
                fillOpacity: 0.3,
                className: 'highlighted-polygon'
            }
        }).addTo(selectionLayer);
        
    } else if (z >= 14 && z < 17) {
        // Nivel micro
        titulo = "츼REA POSTAL";
        const closestWatermark = findClosestWatermark(e.latlng, microWatermarkCache, 0.01);
        
        if (closestWatermark && closestWatermark.feature === feature) {
            finalCode += `-${closestWatermark.code}`;
            
            L.polygon(closestWatermark.bounds, {
                color: "#3498db", 
                weight: 3, 
                fillColor: "#3498db",
                fillOpacity: 0.5,
                className: 'highlighted-polygon'
            }).addTo(selectionLayer);
            
            L.marker(closestWatermark.center, {
                icon: L.divIcon({ 
                    className: 'micro-selection-label', 
                    html: `<div style="background: rgba(255,255,255,0.95); color: #3498db; padding: 2px 5px; border-radius: 3px; border: 2px solid #3498db; font-weight: bold;">${closestWatermark.code}</div>`, 
                    iconSize: [50, 22],
                    iconAnchor: [25, 11]
                }),
                zIndexOffset: 1000
            }).addTo(selectionLayer);
        }
        
    } else {
        // Nivel nano
        titulo = "C칍DIGO POSTAL";
        const closestWatermark = findClosestWatermark(e.latlng, nanoWatermarkCache, 0.002);
        
        if (closestWatermark && closestWatermark.feature === feature) {
            const microKey = `f${fid}-micro-${closestWatermark.indices.microIx}-${closestWatermark.indices.microIy}`;
            const microWatermark = microWatermarkCache.get(microKey);
            
            if (microWatermark) {
                finalCode += `-${microWatermark.code}-${closestWatermark.code}`;
                
                L.polygon(closestWatermark.bounds, {
                    color: "#2980b9", 
                    weight: 3, 
                    fillColor: "#2980b9",
                    fillOpacity: 0.5,
                    className: 'highlighted-polygon'
                }).addTo(selectionLayer);
                
                labelLayer.eachLayer(function(layer) {
                    if (layer instanceof L.Marker) {
                        const markerLatLng = layer.getLatLng();
                        const distance = markerLatLng.distanceTo(closestWatermark.center);
                        if (distance < 5) {
                            layer.setOpacity(0);
                            hiddenLabels.push(layer);
                        }
                    }
                });
                
                L.marker(closestWatermark.center, {
                    icon: L.divIcon({ 
                        className: 'nano-selection-label', 
                        html: `<div style="background: white; color: #2980b9; padding: 2px 5px; border-radius: 3px; border: 2px solid #2980b9; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${closestWatermark.code}</div>`, 
                        iconSize: [45, 22],
                        iconAnchor: [22, 11]
                    }),
                    zIndexOffset: 1000
                }).addTo(selectionLayer);
                
                if (microWatermark) {
                    L.polygon(microWatermark.bounds, {
                        color: "#3498db", 
                        weight: 2, 
                        fillColor: "transparent",
                        dashArray: "5, 5",
                        opacity: 0.4
                    }).addTo(selectionLayer);
                }
            }
        }
    }

    const ws = encodeURIComponent(`游늸 Mi ubicaci칩n: ${finalCode}\nGPS: ${e.latlng.lat.toFixed(6)},${e.latlng.lng.toFixed(6)}`);
    
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(e.latlng.lat + 0.0004, e.latlng.lng);
    
    const popup = L.popup({offset: popupOffset})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center;">
                <small>${titulo}</small><br>
                <b style="font-size: 16px;">${finalCode}</b><br>
                <div class="polygon-info">
                    ${props.PROV_NOMB} | ${props.VM_LEVEL}<br>
                    츼rea: ${props.area_km2} km
                </div>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${e.latlng.lat},${e.latlng.lng}')">游늸 MAPS</button>
                <button class="btn-ws" onclick="window.open('https://wa.me/?text=${ws}')">游눫 WS</button>
            </div>
        `)
        .openOn(mymap);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
        restoreHiddenLabels();
    });
});

// Buscador
document.getElementById('search-btn').addEventListener('click', () => {
    const code = document.getElementById('search-input').value.trim().toUpperCase();
    if (!code || !rawZonas) return;
    
    const parts = code.split('-');
    
    if (parts.length >= 2) {
        // Buscar por provincia + VM_LEVEL (ej: "HER-K4299")
        const provinciaSearch = parts[0];
        const vmSearch = parts[1];
        
        let feature = rawZonas.features.find(f => 
            f.properties.codigo === `${provinciaSearch}-${vmSearch}` ||
            f.properties.PROV_NOMB.startsWith(provinciaSearch) && 
            f.properties.VM_LEVEL === vmSearch
        );
        
        if (feature) {
            const bounds = L.geoJSON(feature).getBounds();
            const zoomLevel = parts.length > 2 ? 18 : parts.length > 1 ? 16 : 12;
            
            selectionLayer.clearLayers();
            restoreHiddenLabels();
            
            L.geoJSON(feature, {
                style: {
                    color: "#3498db", 
                    weight: 3, 
                    fillColor: "#3498db",
                    fillOpacity: 0.3
                }
            }).addTo(selectionLayer);
            
            mymap.fitBounds(bounds, {padding: [50, 50]});
            mymap.setZoom(zoomLevel);
        } else {
            alert("Zona no encontrada: " + code);
        }
    }
});

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = '游꿢';
        b.title = "Ubicar mi posici칩n";
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:18}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// Control de capas
L.control.layers(null, {
    "Zonas Postales": zonasGeoLayer,
    "Cuadr칤cula": gridLayer,
    "Selecci칩n": selectionLayer,
    "Mi ubicaci칩n": userLocationLayer
}, {collapsed: false}).addTo(mymap);

// Toggle labels
$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    updateGridAndLabels();
});

// Eventos
mymap.on('moveend zoomend', updateGridAndLabels);
mymap.on('zoomstart movestart', function() {
    selectionLayer.clearLayers();
    restoreHiddenLabels();
});

mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    L.marker(e.latlng, {
        icon: L.divIcon({
            className: 'user-location-icon',
            html: '游늸',
            iconSize: [30, 30]
        }),
        zIndexOffset: 1000
    }).addTo(userLocationLayer);
});

// Inicializar
updateGridAndLabels();
</script>
</body>
</html>
