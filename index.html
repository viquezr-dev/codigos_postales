<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL DE PANAM√Å</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 250px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .leaflet-top.leaflet-right { top: 80px !important; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        
        /* WATERMARKS M√ÅS GRANDES Y VISIBLES */
        .watermark-label-fixed { 
            background: none!important; 
            border:none!important; 
            color: #1a73e8!important; 
            text-align: center; 
            pointer-events: none!important; 
            text-shadow: 2px 2px 3px white, -2px -2px 3px white, 2px -2px 3px white, -2px 2px 3px white;
            font-size: 14px !important; /* AUMENTADO de 12px */
            font-weight: bold !important;
        }
        .micro-label-fixed { 
            background: none!important; 
            border:none!important; 
            color: #3498db!important; 
            text-align: center; 
            pointer-events: none!important; 
            text-shadow: 2px 2px 3px white, -2px -2px 3px white, 2px -2px 3px white, -2px 2px 3px white;
            font-size: 11px !important; /* AUMENTADO de 9px */
            font-weight: bold !important;
        }
        .nano-label-fixed { 
            background: none!important; 
            border:none!important; 
            color: #2980b9!important; 
            text-align: center; 
            pointer-events: none!important; 
            text-shadow: 1px 1px 2px white, -1px -1px 2px white, 1px -1px 2px white, -1px 1px 2px white;
            font-size: 9px !important; /* AUMENTADO de 8px */
            font-weight: bold !important;
        }
        
        .btn-nav, .btn-ws { display: inline-block; padding: 6px 10px; color: white!important; text-decoration: none!important; border-radius: 4px; font-weight: bold; font-size: 10px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-polygon { 
            animation: pulse 2s infinite; 
            position: relative;
        }
        @keyframes pulse {
            0% { fill-opacity: 0.4; }
            50% { fill-opacity: 0.7; }
            100% { fill-opacity: 0.4; }
        }
        
        /* TEXTO DENTRO DE LA CASILLA RESALTADA */
        .nano-label-inside {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white !important;
            font-size: 10px !important;
            font-weight: bold !important;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 1000;
            text-align: center;
            white-space: nowrap;
        }
        
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            max-width: 200px !important;
        }
        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        .estafeta-popup .leaflet-popup-content-wrapper {
            background: #d4edda;
            border: 2px solid #28a745;
            border-radius: 8px;
        }
        .estafeta-popup .leaflet-popup-tip {
            background: #28a745;
        }
        .ruta-popup .leaflet-popup-content-wrapper {
            background: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 8px;
        }
        .ruta-popup .leaflet-popup-tip {
            background: #dc3545;
        }
        .zona-popup .leaflet-popup-content-wrapper {
            background: #e9ecef;
            border: 2px solid #6c757d;
            border-radius: 8px;
        }
        .zona-popup .leaflet-popup-tip {
            background: #6c757d;
        }
        .grid-macro { stroke-dasharray: none; }
        .grid-micro { stroke-dasharray: 5, 5; }
        .grid-nano { stroke-dasharray: 2, 3; }
        
        /* POPUP NANO M√ÅS PEQUE√ëO Y CON NUEVO FORMATO */
        .nano-popup .leaflet-popup-content-wrapper {
            background: #e3f2fd;
            border: 2px solid #1976d2;
            border-radius: 8px;
            max-width: 200px !important;
            padding: 5px !important;
        }
        .nano-popup .leaflet-popup-tip {
            background: #1976d2;
        }
        
        /* GLOBO PARA EL C√ìDIGO POSTAL */
        .codigo-globo {
            background: #1976d2;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 15px;
            font-weight: bold;
            margin: 8px 0;
            text-align: center;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        /* POPUP DE B√öSQUEDA M√ÅS PEQUE√ëO */
        .search-popup .leaflet-popup-content-wrapper {
            background: #f8f9fa;
            border: 2px solid #6c757d;
            border-radius: 8px;
            max-width: 180px !important;
            padding: 8px !important;
        }
        .search-popup .leaflet-popup-tip {
            background: #6c757d;
        }
    </style>
</head>
<body>

<div class="map-title"><h1>SISTEMA POSTAL DE PANAM√Å</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: A6218-23YHTV">
    <button id="search-btn">IR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
// ==============================================
// CONFIGURACI√ìN DEL SISTEMA 0.1¬∞ - CORREGIDO
// ==============================================
const GRID_CONFIG = {
    ORIGIN_LAT: 9.9,
    ORIGIN_LNG: -83.1,
    RES_MACRO: 0.1,
    RES_MICRO: 0.1 / 24,
    RES_NANO: 0.1 / 600,
    ALPHABET: "23456789BCDFGHJKLMNPQRSTVWXYZ",
    MACROS_X: 60,
    MACROS_Y: 27
};

// ==============================================
// INICIALIZACI√ìN DEL MAPA
// ==============================================
const mymap = L.map('mapid').setView([8.50, -80.0], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas
const zonasGeoLayer = L.layerGroup().addTo(mymap);
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const rutasLayer = L.layerGroup().addTo(mymap);
const estafetasPointsLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawZonas = null;
let rutasData = null, estafetasData = null;
let labelsEnabled = true;

// ==============================================
// FUNCIONES DEL SISTEMA 0.1¬∞ - CORREGIDAS
// ==============================================

// 1. Convertir coordenada ‚Üí √≠ndices (CON L√çMITES)
function coordenadaAIndices(lat, lng) {
    const { ORIGIN_LAT, ORIGIN_LNG, RES_MACRO, RES_MICRO, RES_NANO, MACROS_X, MACROS_Y } = GRID_CONFIG;
    
    if (lat > ORIGIN_LAT || lat < (ORIGIN_LAT - (MACROS_Y * RES_MACRO)) ||
        lng < ORIGIN_LNG || lng > (ORIGIN_LNG + (MACROS_X * RES_MACRO))) {
        return null;
    }
    
    const deltaLng = lng - ORIGIN_LNG;
    const deltaLat = ORIGIN_LAT - lat;
    
    const macroX = Math.floor(deltaLng / RES_MACRO);
    const macroY = Math.floor(deltaLat / RES_MACRO);
    
    const microX = Math.floor((deltaLng % RES_MACRO) / RES_MICRO);
    const microY = Math.floor((deltaLat % RES_MACRO) / RES_MICRO);
    
    const nanoX = Math.floor((((deltaLng % RES_MACRO) % RES_MICRO) / RES_NANO));
    const nanoY = Math.floor((((deltaLat % RES_MACRO) % RES_MICRO) / RES_NANO));
    
    return { 
        macroX: Math.min(macroX, MACROS_X - 1), 
        macroY: Math.min(macroY, MACROS_Y - 1),
        microX: Math.min(microX, 23), 
        microY: Math.min(microY, 23),
        nanoX: Math.min(nanoX, 24), 
        nanoY: Math.min(nanoY, 24)
    };
}

// 2. Convertir n√∫mero a base30 - VERSI√ìN MEJORADA
function toBase30(num, digits) {
    const { ALPHABET } = GRID_CONFIG;
    
    if (typeof num !== 'number' || isNaN(num) || !isFinite(num)) {
        return "??";
    }
    
    num = Math.abs(Math.floor(num));
    const maxVal = Math.pow(30, digits) - 1;
    if (num > maxVal) {
        num = num % maxVal;
    }
    
    let result = '';
    
    for (let i = 0; i < digits; i++) {
        const index = num % 30;
        
        if (index >= 0 && index < ALPHABET.length) {
            result = ALPHABET[index] + result;
        } else {
            result = ALPHABET[0] + result;
        }
        
        num = Math.floor(num / 30);
    }
    
    return result;
}

// 3. Generar PanamaCode (8 caracteres, SIN +)
function generarPanamaCode(lat, lng) {
    const indices = coordenadaAIndices(lat, lng);
    if (!indices) return null;
    
    const macroNum = indices.macroX * 100 + indices.macroY;
    const macroCode = toBase30(macroNum, 2);
    
    const microNum = indices.microX * 100 + indices.microY;
    const microCode = toBase30(microNum, 4);
    
    const nanoNum = indices.nanoX * 100 + indices.nanoY;
    const nanoCode = toBase30(nanoNum, 2);
    
    return macroCode + microCode + nanoCode;
}

// 4. Obtener √∫ltimos 6 d√≠gitos
function obtenerUltimos6Digitos(panamaCode) {
    if (!panamaCode || panamaCode.length < 6) return "ERROR";
    return panamaCode.slice(-6);
}

// 5. Generar c√≥digo postal completo
function generarCodigoPostal(lat, lng, vmLevel) {
    const panamaCode = generarPanamaCode(lat, lng);
    if (!panamaCode) return null;
    
    const ultimos6 = obtenerUltimos6Digitos(panamaCode);
    
    return {
        panamaCode: panamaCode,
        codigoPostal: `${vmLevel || 'SINVM'}-${ultimos6}`
    };
}

// ==============================================
// FUNCIONES AUXILIARES
// ==============================================

function obtenerVMLEVEL(latlng) {
    if (!rawZonas) return null;
    
    const punto = [latlng.lng, latlng.lat];
    const zonasEnPunto = leafletPip.pointInLayer(punto, L.geoJSON(rawZonas));
    
    if (zonasEnPunto.length > 0) {
        return zonasEnPunto[0].feature.properties.VM_LEVEL;
    }
    
    return null;
}

function estaEnAreaDefinida(latlng) {
    if (!rawZonas) return false;
    
    const punto = [latlng.lng, latlng.lat];
    const zonasEnPunto = leafletPip.pointInLayer(punto, L.geoJSON(rawZonas));
    return zonasEnPunto.length > 0;
}

// ==============================================
// DIBUJAR GRID F√çSICO - MEJORADO (M√ÅS WATERMARKS MICRO)
// ==============================================

function dibujarGridFisico() {
    const z = mymap.getZoom();
    
    if (z < 10) {
        gridLayer.clearLayers();
        labelLayer.clearLayers();
        return;
    }
    
    gridLayer.clearLayers();
    labelLayer.clearLayers();
    
    const bounds = mymap.getBounds();
    const { ORIGIN_LAT, ORIGIN_LNG, RES_MACRO, RES_MICRO, RES_NANO, MACROS_X, MACROS_Y } = GRID_CONFIG;
    
    const visibleMacroXStart = Math.max(0, Math.floor((bounds.getWest() - ORIGIN_LNG) / RES_MACRO) - 1);
    const visibleMacroXEnd = Math.min(MACROS_X, Math.ceil((bounds.getEast() - ORIGIN_LNG) / RES_MACRO) + 1);
    const visibleMacroYStart = Math.max(0, Math.floor((ORIGIN_LAT - bounds.getNorth()) / RES_MACRO) - 1);
    const visibleMacroYEnd = Math.min(MACROS_Y, Math.ceil((ORIGIN_LAT - bounds.getSouth()) / RES_MACRO) + 1);
    
    // ZOOM 10-13: SOLO MACROS
    if (z >= 10 && z < 14) {
        for (let mx = visibleMacroXStart; mx < visibleMacroXEnd; mx++) {
            for (let my = visibleMacroYStart; my < visibleMacroYEnd; my++) {
                const lat1 = ORIGIN_LAT - (my * RES_MACRO);
                const lng1 = ORIGIN_LNG + (mx * RES_MACRO);
                const lat2 = lat1 - RES_MACRO;
                const lng2 = lng1 + RES_MACRO;
                
                L.rectangle([[lat1, lng1], [lat2, lng2]], {
                    color: '#1a73e8',
                    weight: 2,
                    opacity: 0.6,
                    fillOpacity: 0,
                    className: 'grid-macro'
                }).addTo(gridLayer);
                
                if (labelsEnabled) {
                    const centroLat = lat1 - (RES_MACRO / 2);
                    const centroLng = lng1 + (RES_MACRO / 2);
                    
                    const macroNum = mx * 100 + my;
                    const macroCode = toBase30(macroNum, 2);
                    
                    if (macroCode && macroCode.length === 2) {
                        L.marker([centroLat, centroLng], {
                            icon: L.divIcon({
                                className: 'watermark-label-fixed',
                                html: `<div>${macroCode}</div>`,
                                iconSize: [50, 25],
                                iconAnchor: [25, 12]
                            }),
                            zIndexOffset: -1000
                        }).addTo(labelLayer);
                    }
                }
            }
        }
    }
    
    // ZOOM 14-16: MICROS - M√ÅS WATERMARKS (cada 3 en lugar de cada 6)
    else if (z >= 14 && z < 17) {
        for (let mx = visibleMacroXStart; mx < visibleMacroXEnd; mx++) {
            for (let my = visibleMacroYStart; my < visibleMacroYEnd; my++) {
                const macroLat1 = ORIGIN_LAT - (my * RES_MACRO);
                const macroLng1 = ORIGIN_LNG + (mx * RES_MACRO);
                const macroLat2 = macroLat1 - RES_MACRO;
                const macroLng2 = macroLng1 + RES_MACRO;
                
                L.rectangle([[macroLat1, macroLng1], [macroLat2, macroLng2]], {
                    color: '#1a73e8',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0,
                    className: 'grid-macro'
                }).addTo(gridLayer);
                
                // Dibujar l√≠neas micro m√°s visibles
                for (let i = 0; i <= 24; i += 3) {
                    for (let j = 0; j <= 24; j += 3) {
                        const microLat1 = macroLat1 - (j * RES_MICRO);
                        const microLng1 = macroLng1 + (i * RES_MICRO);
                        const microLat2 = microLat1 - (3 * RES_MICRO);
                        const microLng2 = microLng1 + (3 * RES_MICRO);
                        
                        L.rectangle([[microLat1, microLng1], [microLat2, microLng2]], {
                            color: '#3498db',
                            weight: i % 6 === 0 ? 1.5 : 0.8,
                            opacity: i % 6 === 0 ? 0.7 : 0.4,
                            dashArray: i % 6 === 0 ? 'none' : '5,5',
                            fillOpacity: 0,
                            className: 'grid-micro'
                        }).addTo(gridLayer);
                        
                        // M√ÅS WATERMARKS MICRO (cada 3 en lugar de cada 12)
                        if (labelsEnabled && i % 6 === 0 && j % 6 === 0) {
                            const centroLat = microLat1 - (1.5 * RES_MICRO);
                            const centroLng = microLng1 + (1.5 * RES_MICRO);
                            
                            const microNum = i * 100 + j;
                            const microCode = toBase30(microNum, 4);
                            
                            if (microCode && microCode.length === 4) {
                                L.marker([centroLat, centroLng], {
                                    icon: L.divIcon({
                                        className: 'micro-label-fixed',
                                        html: `<div>${microCode}</div>`,
                                        iconSize: [70, 25],
                                        iconAnchor: [35, 12]
                                    }),
                                    zIndexOffset: -1000
                                }).addTo(labelLayer);
                            }
                        }
                    }
                }
            }
        }
    }
    
    // ZOOM 17+: NANOS
    else if (z >= 17) {
        for (let mx = visibleMacroXStart; mx < visibleMacroXEnd; mx++) {
            for (let my = visibleMacroYStart; my < visibleMacroYEnd; my++) {
                const macroLat1 = ORIGIN_LAT - (my * RES_MACRO);
                const macroLng1 = ORIGIN_LNG + (mx * RES_MACRO);
                
                L.rectangle([
                    [macroLat1, macroLng1],
                    [macroLat1 - RES_MACRO, macroLng1 + RES_MACRO]
                ], {
                    color: '#1a73e8',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0,
                    className: 'grid-macro'
                }).addTo(gridLayer);
                
                // L√≠neas micro como referencia
                for (let i = 0; i <= 24; i++) {
                    const vLat1 = macroLat1;
                    const vLng1 = macroLng1 + (i * RES_MICRO);
                    const vLat2 = macroLat1 - RES_MACRO;
                    const vLng2 = vLng1;
                    
                    L.polyline([[vLat1, vLng1], [vLat2, vLng2]], {
                        color: '#3498db',
                        weight: 1.0,
                        opacity: 0.6,
                        className: 'grid-micro grid-helper'
                    }).addTo(gridLayer);
                    
                    const hLat1 = macroLat1 - (i * RES_MICRO);
                    const hLng1 = macroLng1;
                    const hLat2 = hLat1;
                    const hLng2 = macroLng1 + RES_MACRO;
                    
                    L.polyline([[hLat1, hLng1], [hLat2, hLng2]], {
                        color: '#3498db',
                        weight: 1.0,
                        opacity: 0.6,
                        className: 'grid-micro grid-helper'
                    }).addTo(gridLayer);
                }
                
                // L√≠neas nano
                for (let mi = 0; mi < 24; mi++) {
                    for (let mj = 0; mj < 24; mj++) {
                        const microLat1 = macroLat1 - (mj * RES_MICRO);
                        const microLng1 = macroLng1 + (mi * RES_MICRO);
                        
                        for (let ni = 5; ni < 25; ni += 5) {
                            const nanoLng = microLng1 + (ni * RES_NANO);
                            L.polyline([
                                [microLat1, nanoLng],
                                [microLat1 - RES_MICRO, nanoLng]
                            ], {
                                color: '#2980b9',
                                weight: 0.4,
                                opacity: 0.3,
                                dashArray: '2, 3',
                                className: 'grid-nano nano-grid-line'
                            }).addTo(gridLayer);
                        }
                        
                        for (let nj = 5; nj < 25; nj += 5) {
                            const nanoLat = microLat1 - (nj * RES_NANO);
                            L.polyline([
                                [nanoLat, microLng1],
                                [nanoLat, microLng1 + RES_MICRO]
                            ], {
                                color: '#2980b9',
                                weight: 0.4,
                                opacity: 0.3,
                                dashArray: '2, 3',
                                className: 'grid-nano nano-grid-line'
                            }).addTo(gridLayer);
                        }
                    }
                }
                
                // Watermarks nano (algunos)
                if (labelsEnabled) {
                    for (let mi = 0; mi < 24; mi += 8) {
                        for (let mj = 0; mj < 24; mj += 8) {
                            const microLat1 = macroLat1 - (mj * RES_MICRO);
                            const microLng1 = macroLng1 + (mi * RES_MICRO);
                            
                            for (let ni = 8; ni < 25; ni += 8) {
                                for (let nj = 8; nj < 25; nj += 8) {
                                    const nanoLat = microLat1 - (nj * RES_NANO);
                                    const nanoLng = microLng1 + (ni * RES_NANO);
                                    
                                    if (!bounds.contains([nanoLat, nanoLng])) continue;
                                    
                                    const nanoNum = ni * 100 + nj;
                                    const nanoCode = toBase30(nanoNum, 2);
                                    
                                    if (nanoCode && nanoCode.length === 2) {
                                        L.marker([nanoLat, nanoLng], {
                                            icon: L.divIcon({
                                                className: 'nano-label-fixed',
                                                html: `<div>${nanoCode}</div>`,
                                                iconSize: [35, 15],
                                                iconAnchor: [17, 7]
                                            }),
                                            zIndexOffset: -1000
                                        }).addTo(labelLayer);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// ==============================================
// BUSCADOR CON DEPURACI√ìN INTEGRADA - CORREGIDO
// ==============================================

document.getElementById('search-btn').addEventListener('click', () => {
    const input = document.getElementById('search-input').value.trim().toUpperCase();
    
    if (!input) {
        alert("Ingresa un c√≥digo postal");
        return;
    }
    
    // DEPURACI√ìN: Mostrar lo que se est√° buscando
    console.log("üîç BUSCANDO:", input);
    
    // LIMPIAR SELECCI√ìN ANTERIOR
    selectionLayer.clearLayers();
    
    // FORMATO: VM_LEVEL-C√≥digo6Digitos (ej: K4299-222KQ2)
    if (input.includes('-')) {
        const partes = input.split('-');
        const vmLevel = partes[0]; // Ej: "A6238"
        const codigo6Digitos = partes[1]; // Ej: "235S5M"
        
        console.log("üìã PARTES ANALIZADAS:", { 
            vmLevel: vmLevel, 
            codigo6Digitos: codigo6Digitos,
            longitud: codigo6Digitos ? codigo6Digitos.length : 0 
        });
        
        if (!codigo6Digitos || codigo6Digitos.length !== 6) {
            alert(`El c√≥digo debe tener 6 d√≠gitos\nRecibido: "${codigo6Digitos}" (${codigo6Digitos ? codigo6Digitos.length : 0} chars)`);
            return;
        }
        
        // 1. BUSCAR LA ZONA POR VM_LEVEL
        if (!rawZonas || !rawZonas.features) {
            alert("Las zonas no est√°n cargadas a√∫n. Espera unos segundos.");
            return;
        }
        
        console.log("üîç Buscando zona con VM_LEVEL:", vmLevel);
        console.log("üìä Total de zonas cargadas:", rawZonas.features.length);
        
        // Mostrar primeras 5 zonas para referencia
        const zonasEjemplo = rawZonas.features
            .filter(f => f.properties && f.properties.VM_LEVEL)
            .slice(0, 5)
            .map(f => `${f.properties.VM_LEVEL} (${f.properties.PROV_NOMB || 'Sin nombre'})`);
        
        console.log("üìå Primeras 5 zonas disponibles:", zonasEjemplo);
        
        const zonaFeature = rawZonas.features.find(f => {
            const propVM = f.properties && f.properties.VM_LEVEL;
            return propVM && propVM.toUpperCase() === vmLevel;
        });
        
        if (!zonaFeature) {
            alert(`‚ùå Zona postal "${vmLevel}" no encontrada\n\nVerifica que la zona existe usando la tabla de referencia.`);
            
            // Mostrar zonas similares para ayudar
            const zonasSimilares = rawZonas.features
                .filter(f => f.properties && f.properties.VM_LEVEL)
                .filter(f => f.properties.VM_LEVEL.includes(vmLevel.substring(0, 3)))
                .slice(0, 5)
                .map(f => f.properties.VM_LEVEL);
            
            if (zonasSimilares.length > 0) {
                console.log("üîç Zonas similares encontradas:", zonasSimilares);
            }
            
            return;
        }
        
        console.log("‚úÖ Zona encontrada:", {
            VM_LEVEL: zonaFeature.properties.VM_LEVEL,
            PROVINCIA: zonaFeature.properties.PROV_NOMB,
            AREA: zonaFeature.properties.AREA
        });
        
        // ==============================================
        // DECODIFICACI√ìN MEJORADA
        // ==============================================
        
        const microCode = codigo6Digitos.substring(0, 4); // Ej: "235S"
        const nanoCode = codigo6Digitos.substring(4, 6);  // Ej: "5M"
        
        console.log("üî§ C√≥digos separados:", { 
            microCode: microCode, 
            nanoCode: nanoCode 
        });
        
        // ALFABETO DEL SISTEMA (¬°VERIFICA QUE EST√â BIEN!)
        const ALFABETO = "23456789BCDFGHJKLMNPQRSTVWXYZ";
        console.log("üî° Alfabeto usado (30 caracteres, sin vocales):");
        console.log("   √çndices:", ALFABETO.split('').map((c, i) => `${c}=${i}`).join(' '));
        
        // FUNCI√ìN DE DECODIFICACI√ìN ROBUSTA
        function decodificarBase30(codigo) {
            console.log(`üìä Decodificando "${codigo}":`);
            let resultado = 0;
            
            for (let i = 0; i < codigo.length; i++) {
                const char = codigo.charAt(i);
                const indice = ALFABETO.indexOf(char);
                
                if (indice === -1) {
                    console.error(`‚ùå ERROR: Car√°cter '${char}' no encontrado en el alfabeto!`);
                    console.error(`   Alfabeto: ${ALFABETO}`);
                    return null;
                }
                
                console.log(`   ${i}: '${char}' ‚Üí √≠ndice ${indice}`);
                resultado = resultado * 30 + indice;
            }
            
            console.log(`   üî¢ N√∫mero resultante: ${resultado}`);
            return resultado;
        }
        
        // DECODIFICAR MICRO (4 caracteres)
        console.log("--- DECODIFICANDO MICRO (4 chars) ---");
        const microNum = decodificarBase30(microCode);
        
        if (microNum === null || microNum === undefined) {
            alert(`Error decodificando micro c√≥digo: ${microCode}`);
            return;
        }
        
        // IMPORTANTE: Los micros van de 0 a 23
        const microX = Math.floor(microNum / 100);
        const microY = microNum % 100;
        
        console.log(`üìç Micro posici√≥n calculada:`, {
            n√∫mero: microNum,
            X: microX,
            Y: microY,
            v√°lido: (microX >= 0 && microX < 24 && microY >= 0 && microY < 24)
        });
        
        if (microX >= 24 || microY >= 24 || microX < 0 || microY < 0) {
            alert(`‚ùå Posici√≥n micro fuera de rango (0-23): X=${microX}, Y=${microY}`);
            return;
        }
        
        // DECODIFICAR NANO (2 caracteres)
        console.log("--- DECODIFICANDO NANO (2 chars) ---");
        const nanoNum = decodificarBase30(nanoCode);
        
        if (nanoNum === null || nanoNum === undefined) {
            alert(`Error decodificando nano c√≥digo: ${nanoCode}`);
            return;
        }
        
        // IMPORTANTE: Los nanos van de 0 a 24
        const nanoX = Math.floor(nanoNum / 100);
        const nanoY = nanoNum % 100;
        
        console.log(`üìç Nano posici√≥n calculada:`, {
            n√∫mero: nanoNum,
            X: nanoX,
            Y: nanoY,
            v√°lido: (nanoX >= 0 && nanoX < 25 && nanoY >= 0 && nanoY < 25)
        });
        
        if (nanoX >= 25 || nanoY >= 25 || nanoX < 0 || nanoY < 0) {
            alert(`‚ùå Posici√≥n nano fuera de rango (0-24): X=${nanoX}, Y=${nanoY}`);
            return;
        }
        
        console.log("‚úÖ DECODIFICACI√ìN COMPLETADA:", {
            micro: [microX, microY],
            nano: [nanoX, nanoY]
        });
        
        // ==============================================
        // CALCULAR POSICI√ìN GEOGR√ÅFICA
        // ==============================================
        
        const zonaGeoJSON = L.geoJSON(zonaFeature);
        const bounds = zonaGeoJSON.getBounds();
        
        console.log("üó∫Ô∏è L√≠mites de la zona:", {
            norte: bounds.getNorth().toFixed(6),
            sur: bounds.getSouth().toFixed(6),
            este: bounds.getEast().toFixed(6),
            oeste: bounds.getWest().toFixed(6),
            ancho: (bounds.getEast() - bounds.getWest()).toFixed(6),
            alto: (bounds.getNorth() - bounds.getSouth()).toFixed(6)
        });
        
        const zonaWidth = bounds.getEast() - bounds.getWest();
        const zonaHeight = bounds.getNorth() - bounds.getSouth();
        
        // Cada zona se divide en 24x24 micros
        const microWidth = zonaWidth / 24;
        const microHeight = zonaHeight / 24;
        
        // Cada micro se divide en 25x25 nanos
        const nanoWidth = microWidth / 25;
        const nanoHeight = microHeight / 25;
        
        console.log("üìè Dimensiones calculadas:", {
            microWidth: microWidth.toFixed(8),
            microHeight: microHeight.toFixed(8),
            nanoWidth: nanoWidth.toFixed(8),
            nanoHeight: nanoHeight.toFixed(8)
        });
        
        // Calcular posici√≥n del CENTRO de la celda nano
        const lngCentro = bounds.getWest() + 
                         (microX * microWidth) + 
                         (nanoX * nanoWidth) + 
                         (nanoWidth / 2);
        
        const latCentro = bounds.getNorth() - 
                         (microY * microHeight) - 
                         (nanoY * nanoHeight) - 
                         (nanoHeight / 2);
        
        console.log("üåç POSICI√ìN FINAL CALCULADA:", {
            lat: latCentro.toFixed(6),
            lng: lngCentro.toFixed(6),
            coordenadas: `${latCentro.toFixed(6)}, ${lngCentro.toFixed(6)}`
        });
        
        // ==============================================
        // VISUALIZACI√ìN EN EL MAPA
        // ==============================================
        
        // 1. Centrar mapa en la posici√≥n
        mymap.setView([latCentro, lngCentro], 19);
        
        // 2. Resaltar la zona completa (transparente, solo borde)
        L.geoJSON(zonaFeature, {
            style: {
                color: '#ff9800',
                weight: 3,
                fillColor: '#ff9800',
                fillOpacity: 0.15,
                className: 'highlighted-polygon'
            }
        }).addTo(selectionLayer);
        
        // 3. Calcular l√≠mites exactos de la celda nano
        const lat1 = bounds.getNorth() - (microY * microHeight) - (nanoY * nanoHeight);
        const lng1 = bounds.getWest() + (microX * microWidth) + (nanoX * nanoWidth);
        const lat2 = lat1 - nanoHeight;
        const lng2 = lng1 + nanoWidth;
        
        console.log("üî≤ L√≠mites celda nano:", {
            esquinaNO: [lat1.toFixed(6), lng1.toFixed(6)],
            esquinaSE: [lat2.toFixed(6), lng2.toFixed(6)]
        });
        
        // 4. Dibujar celda nano resaltada
        L.rectangle([[lat1, lng1], [lat2, lng2]], {
            color: '#e74c3c',
            weight: 4,
            fillColor: '#e74c3c',
            fillOpacity: 0.6,
            className: 'highlighted-polygon'
        }).addTo(selectionLayer);
        
        // 5. Agregar texto dentro de la casilla
        L.marker([latCentro, lngCentro], {
            icon: L.divIcon({
                className: 'nano-label-inside',
                html: `<div>${nanoCode}</div>`,
                iconSize: [40, 20],
                iconAnchor: [20, 10]
            }),
            zIndexOffset: 1000
        }).addTo(selectionLayer);
        
        // 6. Mostrar popup informativo
        setTimeout(() => {
            L.popup({ className: 'nano-popup' })
                .setLatLng([latCentro, lngCentro])
                .setContent(`
                    <div style="text-align:center; padding: 8px; max-width: 220px;">
                        <div style="font-size: 11px; color: #1976d2; margin-bottom: 5px; font-weight: bold;">
                            üîç C√ìDIGO POSTAL ENCONTRADO
                        </div>
                        
                        <div class="codigo-globo" style="margin: 8px 0; font-size: 15px; letter-spacing: 1px;">
                            ${input}
                        </div>
                        
                        <div style="font-size: 10px; color: #495057; margin: 6px 0; padding: 6px; background: #f8f9fa; border-radius: 4px; text-align: left;">
                            <strong>Zona:</strong> ${vmLevel}<br>
                            <strong>Provincia:</strong> ${zonaFeature.properties.PROV_NOMB || 'N/A'}<br>
                            <strong>Micro posici√≥n:</strong> ${microX},${microY}<br>
                            <strong>Nano posici√≥n:</strong> ${nanoX},${nanoY}
                        </div>
                        
                        <div style="font-size: 9px; color: #495057; margin: 4px 0; padding: 4px; background: #fff; border-radius: 3px; font-family: monospace; border: 1px solid #dee2e6;">
                            üìç ${latCentro.toFixed(6)}, ${lngCentro.toFixed(6)}
                        </div>
                        
                        <div style="display: flex; gap: 5px; justify-content: center; margin-top: 10px;">
                            <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latCentro},${lngCentro}')">üìç MAPS</button>
                            <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç C√≥digo Postal: ${input}\\nüìç ${zonaFeature.properties.PROV_NOMB || ''}\\nüåê GPS: ${latCentro.toFixed(6)}, ${lngCentro.toFixed(6)}`)}')">üí¨ WS</button>
                        </div>
                        
                        <div style="margin-top: 8px; font-size: 8px; color: #6c757d;">
                            Click en el mapa para cerrar
                        </div>
                    </div>
                `)
                .openOn(mymap);
        }, 500);
        
        console.log("‚úÖ B√öSQUEDA COMPLETADA CON √âXITO");
        
    } 
    // CASO: COORDENADAS (igual que antes)
    else if (input.includes(',')) {
        const coords = input.split(',');
        const lat = parseFloat(coords[0].trim());
        const lng = parseFloat(coords[1].trim());
        
        if (!isNaN(lat) && !isNaN(lng)) {
            mymap.setView([lat, lng], 16);
            
            L.circleMarker([lat, lng], {
                radius: 6,
                color: '#e74c3c',
                fillColor: '#e74c3c',
                fillOpacity: 0.8,
                weight: 2
            }).addTo(selectionLayer);
            
            // Generar c√≥digo postal desde coordenadas
            const vmLevel = obtenerVMLEVEL({lat: lat, lng: lng}) || 'SINVM';
            const codigos = generarCodigoPostal(lat, lng, vmLevel);
            
            setTimeout(() => {
                let contenido = `
                    <div style="text-align:center; padding: 8px; max-width: 180px;">
                        <div style="font-size: 11px; color: #1976d2; margin-bottom: 5px; font-weight: bold;">
                            üìç COORDENADAS
                        </div>
                        <div style="font-size: 9px; color: #495057; margin: 4px 0; padding: 4px; background: #f8f9fa; border-radius: 3px; font-family: monospace;">
                            ${lat.toFixed(6)}, ${lng.toFixed(6)}
                        </div>`;
                
                if (codigos) {
                    contenido += `
                        <div style="font-size: 10px; color: #28a745; margin: 4px 0; padding: 4px; background: #d4edda; border-radius: 3px;">
                            <strong>C√≥digo Postal:</strong><br>${codigos.codigoPostal}
                        </div>`;
                }
                
                contenido += `
                        <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${lat},${lng}')" style="padding: 5px 10px; font-size: 10px;">
                            üìç MAPS
                        </button>
                    </div>`;
                
                L.popup()
                    .setLatLng([lat, lng])
                    .setContent(contenido)
                    .openOn(mymap);
            }, 300);
        } else {
            alert("Coordenadas inv√°lidas");
        }
    }
    
    // CASO: SOLO VM_LEVEL (sin c√≥digo)
    else if (rawZonas) {
        const zonaFeature = rawZonas.features.find(f => 
            f.properties && 
            f.properties.VM_LEVEL && 
            f.properties.VM_LEVEL.toUpperCase() === input
        );
        
        if (zonaFeature) {
            const zonaGeoJSON = L.geoJSON(zonaFeature);
            mymap.fitBounds(zonaGeoJSON.getBounds());
            
            selectionLayer.clearLayers();
            L.geoJSON(zonaFeature, {
                style: {
                    color: '#ff9800',
                    weight: 3,
                    fillColor: '#ff9800',
                    fillOpacity: 0.3,
                    className: 'highlighted-polygon'
                }
            }).addTo(selectionLayer);
            
            const bounds = zonaGeoJSON.getBounds();
            const centro = bounds.getCenter();
            
            setTimeout(() => {
                L.popup()
                    .setLatLng(centro)
                    .setContent(`
                        <div style="text-align:center; padding: 8px; max-width: 200px;">
                            <div style="font-size: 11px; color: #1976d2; margin-bottom: 5px; font-weight: bold;">
                                üó∫Ô∏è ZONA POSTAL
                            </div>
                            <div style="font-size: 10px; color: #495057; margin: 4px 0; padding: 4px; background: #f8f9fa; border-radius: 3px;">
                                <strong>VM_LEVEL:</strong> ${input}<br>
                                <strong>Provincia:</strong> ${zonaFeature.properties.PROV_NOMB || 'N/A'}<br>
                                <strong>√Årea:</strong> ${(zonaFeature.properties.AREA / 1000000).toFixed(2)} km¬≤
                            </div>
                            <button class="btn-nav" onclick="mymap.setZoom(17)" style="padding: 5px 10px; font-size: 10px;">
                                üîç Acercar
                            </button>
                        </div>
                    `)
                    .openOn(mymap);
            }, 300);
        } else {
            alert("Formato no reconocido. Usa:\n\n" +
                  "‚Ä¢ C√≥digo postal completo: VM_LEVEL-C√≥digo6Digitos\n" +
                  "  Ejemplo: K4299-222KQ2\n\n" +
                  "‚Ä¢ Solo VM_LEVEL (zona)\n" +
                  "  Ejemplo: K4299\n\n" +
                  "‚Ä¢ Coordenadas: latitud, longitud\n" +
                  "  Ejemplo: 8.123456, -80.123456");
        }
    }
});

// Tambi√©n manejar la tecla Enter en el input
document.getElementById('search-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        document.getElementById('search-btn').click();
    }
});

// ==============================================
// CARGAR DATOS EXISTENTES
// ==============================================

$.getJSON("estafetas.geojson", d => { 
    rawZonas = d; 
    L.geoJSON(d, {
        style: {color: "#2c3e50", weight: 1.5, fillOpacity: 0.05},
        onEachFeature: function(feature, layer) {
            layer.on('click', function(e) {
                mostrarPopupZona(e.latlng, feature);
                L.DomEvent.stopPropagation(e);
            });
        }
    }).addTo(zonasGeoLayer); 
});

$.getJSON("estafetasl.geojson", d => { 
    rutasData = d;
    L.geoJSON(d, {
        style: function(feature) {
            return {
                color: "#e74c3c", 
                weight: 4,
                opacity: 0.8
            };
        },
        onEachFeature: function(feature, layer) {
            layer.on('click', function(e) {
                mostrarPopupRuta(e.latlng, feature);
                L.DomEvent.stopPropagation(e);
            });
        }
    }).addTo(rutasLayer);
});

$.getJSON("estafetasp.geojson", d => { 
    estafetasData = d;
    L.geoJSON(d, {
        pointToLayer: (f, ll) => L.circleMarker(ll, {
            radius: 8,
            color: "#27ae60", 
            fillColor: "#2ecc71", 
            fillOpacity: 0.9,
            weight: 3
        }),
        onEachFeature: function(feature, layer) {
            layer.on('click', function(e) {
                mostrarPopupEstafeta(e.latlng, feature);
                L.DomEvent.stopPropagation(e);
            });
        }
    }).addTo(estafetasPointsLayer);
});

// ==============================================
// EVENTO CLIC PRINCIPAL - MEJORADO
// ==============================================

mymap.on("click", function (e) {
    console.log("Clic en:", e.latlng.lat.toFixed(6), e.latlng.lng.toFixed(6));
    
    // Limpiar selecci√≥n anterior
    selectionLayer.clearLayers();
    
    // Verificar clics en otras capas primero
    const estafetaClic = verificarClicEnEstafetas(e.latlng);
    if (estafetaClic) {
        mostrarPopupEstafeta(e.latlng, estafetaClic);
        return;
    }
    
    const rutaClic = verificarClicEnRutas(e.latlng);
    if (rutaClic) {
        mostrarPopupRuta(e.latlng, rutaClic);
        return;
    }
    
    const zonaClic = verificarClicEnZonas(e.latlng);
    if (zonaClic) {
        mostrarPopupZona(e.latlng, zonaClic);
        return;
    }
    
    // Verificar si est√° en √°rea definida
    if (!estaEnAreaDefinida(e.latlng)) {
        mostrarPopupAreaNoDefinida(e.latlng);
        return;
    }
    
    // SOLO mostrar c√≥digo postal si estamos en zoom nano (>= 17)
    const zoomActual = mymap.getZoom();
    if (zoomActual < 17) {
        mostrarPopupZoomInsuficiente(e.latlng);
        return;
    }
    
    // Generar c√≥digo postal
    const vmLevel = obtenerVMLEVEL(e.latlng) || 'SINVM';
    const codigos = generarCodigoPostal(e.latlng.lat, e.latlng.lng, vmLevel);
    
    if (!codigos) {
        mostrarPopupAreaNoDefinida(e.latlng);
        return;
    }
    
    // Resaltar celda nano CON TEXTO DENTRO
    const indices = coordenadaAIndices(e.latlng.lat, e.latlng.lng);
    if (indices) {
        const { ORIGIN_LAT, ORIGIN_LNG, RES_MICRO, RES_NANO } = GRID_CONFIG;
        
        const lat1 = ORIGIN_LAT - (indices.macroY * GRID_CONFIG.RES_MACRO) - (indices.microY * RES_MICRO) - (indices.nanoY * RES_NANO);
        const lng1 = ORIGIN_LNG + (indices.macroX * GRID_CONFIG.RES_MACRO) + (indices.microX * RES_MICRO) + (indices.nanoX * RES_NANO);
        const lat2 = lat1 - RES_NANO;
        const lng2 = lng1 + RES_NANO;
        
        // Crear el rect√°ngulo resaltado
        const rect = L.rectangle([[lat1, lng1], [lat2, lng2]], {
            color: '#1976d2',
            weight: 3,
            fillColor: '#1976d2',
            fillOpacity: 0.6,
            className: 'highlighted-polygon'
        }).addTo(selectionLayer);
        
        // Calcular centro para el texto
        const centroLat = (lat1 + lat2) / 2;
        const centroLng = (lng1 + lng2) / 2;
        
        // Agregar texto dentro de la casilla
        const textMarker = L.marker([centroLat, centroLng], {
            icon: L.divIcon({
                className: 'nano-label-inside',
                html: `<div>${codigos.codigoPostal.split('-')[1].slice(-2)}</div>`,
                iconSize: [40, 20],
                iconAnchor: [20, 10]
            }),
            zIndexOffset: 1000
        }).addTo(selectionLayer);
    }
    
    // Mostrar popup CON NUEVO FORMATO
    const popupOffset = [0, -45];
    const popupLatLng = L.latLng(e.latlng.lat + 0.00006, e.latlng.lng);
    
    const popup = L.popup({offset: popupOffset, className: 'nano-popup'})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center; padding: 6px; max-width: 190px;">
                <div style="font-size: 11px; color: #1976d2; margin-bottom: 5px; font-weight: bold;">
                    üìç C√ìDIGO POSTAL
                </div>
                
                <div class="codigo-globo" style="margin: 6px 0; font-size: 14px;">
                    ${codigos.codigoPostal}
                </div>
                
                <div style="font-size: 9px; color: #495057; margin: 4px 0; padding: 4px; background: #f8f9fa; border-radius: 3px; font-family: monospace;">
                    GPS: ${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}
                </div>
                
                <div style="font-size: 9px; color: #1976d2; margin: 4px 0; padding: 3px; background: #e3f2fd; border-radius: 3px;">
                    PanamaCode: ${codigos.panamaCode}
                </div>
                
                <div style="display: flex; gap: 5px; justify-content: center; margin-top: 6px;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${e.latlng.lat},${e.latlng.lng}')">üìç MAPS</button>
                    <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç C√≥digo Postal: ${codigos.codigoPostal}\nGPS: ${e.latlng.lat.toFixed(6)},${e.latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
    });
});

// ==============================================
// FUNCIONES RESTANTES (sin cambios)
// ==============================================

function mostrarPopupZoomInsuficiente(latlng) {
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(latlng.lat + 0.00015, latlng.lng);
    
    L.popup({offset: popupOffset, className: 'warning-popup'})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 200px;">
                <div style="font-size: 12px; color: #e74c3c; margin-bottom: 5px; font-weight: bold;">
                    üîç ACERCA PARA C√ìDIGO POSTAL
                </div>
                <div style="font-size: 11px; color: #7f8c8d; margin-bottom: 10px;">
                    Haz zoom (nivel 17+) para obtener el c√≥digo postal exacto
                </div>
                <button class="btn-nav" onclick="mymap.setZoom(17)" style="padding: 6px 12px; font-size: 11px;">
                    üîç ZOOM IN
                </button>
            </div>
        `)
        .openOn(mymap);
}

function verificarClicEnZonas(latlng) {
    if (!rawZonas || !mymap.hasLayer(zonasGeoLayer)) return null;
    const punto = [latlng.lng, latlng.lat];
    const zonasEnPunto = leafletPip.pointInLayer(punto, L.geoJSON(rawZonas));
    return zonasEnPunto.length > 0 ? zonasEnPunto[0].feature : null;
}

function verificarClicEnEstafetas(latlng) {
    if (!estafetasData || !mymap.hasLayer(estafetasPointsLayer)) return null;
    let estafetaMasCercana = null;
    let distanciaMinima = Infinity;
    const TOLERANCIA_METROS = 15;
    const toleranceDegrees = TOLERANCIA_METROS / 111000;
    
    estafetasData.features.forEach(feature => {
        if (feature.geometry.type === 'Point') {
            const puntoEstafeta = {
                lat: feature.geometry.coordinates[1],
                lng: feature.geometry.coordinates[0]
            };
            const dx = latlng.lng - puntoEstafeta.lng;
            const dy = latlng.lat - puntoEstafeta.lat;
            const distancia = Math.sqrt(dx * dx + dy * dy);
            
            if (distancia < distanciaMinima && distancia < toleranceDegrees) {
                distanciaMinima = distancia;
                estafetaMasCercana = feature;
            }
        }
    });
    
    return estafetaMasCercana;
}

function verificarClicEnRutas(latlng) {
    if (!rutasData || !mymap.hasLayer(rutasLayer)) return null;
    let rutaMasCercana = null;
    let distanciaMinima = Infinity;
    const TOLERANCIA_METROS = 10;
    const toleranceDegrees = TOLERANCIA_METROS / 111000;
    
    rutasData.features.forEach(feature => {
        if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {
            let coordinates = [];
            if (feature.geometry.type === 'LineString') {
                coordinates = feature.geometry.coordinates;
            } else if (feature.geometry.type === 'MultiLineString') {
                feature.geometry.coordinates.forEach(line => {
                    coordinates = coordinates.concat(line);
                });
            }
            
            for (let i = 0; i < coordinates.length - 1; i++) {
                const p1 = { lng: coordinates[i][0], lat: coordinates[i][1] };
                const p2 = { lng: coordinates[i + 1][0], lat: coordinates[i + 1][1] };
                const distancia = distanciaPuntoASegmento(latlng, p1, p2);
                
                if (distancia < distanciaMinima && distancia < toleranceDegrees) {
                    distanciaMinima = distancia;
                    rutaMasCercana = feature;
                }
            }
        }
    });
    
    return rutaMasCercana;
}

function distanciaPuntoASegmento(p, a, b) {
    const A = p.lng - a.lng;
    const B = p.lat - a.lat;
    const C = b.lng - a.lng;
    const D = b.lat - a.lat;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    
    if (lenSq === 0) {
        const dx = p.lng - a.lng;
        const dy = p.lat - a.lat;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    let param = dot / lenSq;
    let xx, yy;
    
    if (param < 0) {
        xx = a.lng;
        yy = a.lat;
    } else if (param > 1) {
        xx = b.lng;
        yy = b.lat;
    } else {
        xx = a.lng + param * C;
        yy = a.lat + param * D;
    }
    
    const dx = p.lng - xx;
    const dy = p.lat - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

function mostrarPopupAreaNoDefinida(latlng) {
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(latlng.lat + 0.00015, latlng.lng);
    
    L.popup({offset: popupOffset, className: 'warning-popup'})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 200px;">
                <div style="font-size: 12px; color: #e74c3c; margin-bottom: 5px; font-weight: bold;">
                    ‚ö†Ô∏è √ÅREA NO DEFINIDA
                </div>
                <div style="font-size: 11px; color: #7f8c8d; margin-bottom: 10px;">
                    Fuera de zonas postales definidas
                </div>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')" style="padding: 6px 12px; font-size: 11px;">
                    üìç MAPS
                </button>
            </div>
        `)
        .openOn(mymap);
}

function mostrarPopupZona(latlng, zona) {
    const p = zona.properties || {};
    const nivelVM = p.VM_LEVEL || "N/A";
    const nombre = p.nombre || p.name || `Zona ${nivelVM}`;
    
    const popup = L.popup({className: 'zona-popup'})
        .setLatLng(latlng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 200px;">
                <div style="font-size: 12px; color: #6c757d; margin-bottom: 8px; font-weight: bold;">
                    üó∫Ô∏è ${nombre}
                </div>
                <div style="font-size: 11px; color: #495057; margin-bottom: 10px;">
                    <strong>Nivel VM:</strong> ${nivelVM}
                </div>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')" style="padding: 6px 12px; font-size: 11px;">
                    üìç MAPS
                </button>
            </div>
        `)
        .openOn(mymap);
    
    selectionLayer.clearLayers();
    L.geoJSON(zona, {
        style: {
            color: "#6c757d", 
            weight: 4, 
            fillColor: "#6c757d",
            fillOpacity: 0.3,
            className: 'highlighted-polygon'
        }
    }).addTo(selectionLayer);
}

function mostrarPopupEstafeta(latlng, estafeta) {
    const p = estafeta.properties || {};
    const nombre = p.ESTAF_NAME || p.nombre || p.name || "Estafeta Postal";
    const codigo = p.ESTAF_CODE || p.codigo || p.id || "N/A";
    
    const popup = L.popup({className: 'estafeta-popup'})
        .setLatLng(latlng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 200px;">
                <div style="font-size: 12px; color: #28a745; margin-bottom: 8px; font-weight: bold;">
                    üìÆ ${nombre}
                </div>
                <div style="font-size: 11px; color: #155724; margin-bottom: 10px;">
                    <strong>C√≥digo:</strong> ${codigo}
                </div>
                <div style="display: flex; gap: 8px; justify-content: center;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')" style="padding: 6px 12px; font-size: 11px;">üìç MAPS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
    
    selectionLayer.clearLayers();
    L.circleMarker(latlng, {
        radius: 10,
        color: "#28a745",
        fillColor: "#28a745",
        fillOpacity: 0.9,
        weight: 3
    }).addTo(selectionLayer);
}
// Funci√≥n para decodificar CON verificaci√≥n visual
function decodificarConVerificacion(codigo, nombre) {
    console.log(`\nüî§ DECODIFICANDO ${nombre}: "${codigo}"`);
    
    let resultado = 0;
    let pasos = [];
    
    for (let i = 0; i < codigo.length; i++) {
        const char = codigo.charAt(i);
        const indice = ALFABETO.indexOf(char);
        
        if (indice === -1) {
            console.error(`‚ùå ERROR: Car√°cter '${char}' no est√° en el alfabeto Base30`);
            console.error(`   Alfabeto: ${ALFABETO}`);
            console.error(`   Caracteres permitidos: n√∫meros 2-9 y consonantes (sin vocales)`);
            return null;
        }
        
        pasos.push(`${resultado} √ó 30 + ${indice} = ${resultado * 30 + indice}`);
        resultado = resultado * 30 + indice;
    }
    
    console.log(`   Pasos: ${pasos.join(' ‚Üí ')}`);
    console.log(`   üî¢ Resultado final: ${resultado}`);
    
    return resultado;
}

// √ösala as√≠:
const microNum = decodificarConVerificacion(microCode, "MICRO");
const nanoNum = decodificarConVerificacion(nanoCode, "NANO");
    
function mostrarPopupRuta(latlng, ruta) {
    const p = ruta.properties || {};
    const rutaNombre = p.RUTA || p.nombre || p.name || "Ruta Postal";
    
    const popup = L.popup({className: 'ruta-popup'})
        .setLatLng(latlng)
        .setContent(`
            <div style="text-align:center; padding: 10px; max-width: 200px;">
                <div style="font-size: 12px; color: #dc3545; margin-bottom: 8px; font-weight: bold;">
                    üöö Ruta: ${rutaNombre}
                </div>
                <div style="font-size: 11px; color: #721c24; margin-bottom: 10px;">
                    GPS: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}
                </div>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')" style="padding: 6px 12px; font-size: 11px;">üìç MAPS</button>
            </div>
        `)
        .openOn(mymap);
    
    selectionLayer.clearLayers();
    L.circleMarker(latlng, {
        radius: 6,
        color: "#dc3545",
        fillColor: "#dc3545",
        fillOpacity: 0.8,
        weight: 3
    }).addTo(selectionLayer);
}

// ==============================================
// CONTROLES Y EVENTOS
// ==============================================

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = 'üéØ';
        b.title = "Ubicar mi posici√≥n";
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:18}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// Control de capas
L.control.layers(null, {
    "Zonas (Referencia)": zonasGeoLayer,
    "Rutas": rutasLayer,
    "Estafetas": estafetasPointsLayer,
    "Cuadr√≠cula Postal": gridLayer,
    "Selecci√≥n": selectionLayer,
    "Mi ubicaci√≥n": userLocationLayer
}, {collapsed: false}).addTo(mymap);

// Toggle labels
$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    dibujarGridFisico();
});

// Eventos del mapa optimizados
let gridRedrawTimeout;
mymap.on('moveend zoomend', function() {
    if (gridRedrawTimeout) clearTimeout(gridRedrawTimeout);
    gridRedrawTimeout = setTimeout(() => {
        dibujarGridFisico();
    }, 100);
});

mymap.on('zoomstart movestart', function() {
    selectionLayer.clearLayers();
});

// Ubicaci√≥n del usuario
mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    L.marker(e.latlng, {
        icon: L.divIcon({
            className: 'user-location-icon',
            html: 'üìç',
            iconSize: [30, 30]
        }),
        zIndexOffset: 1000
    }).addTo(userLocationLayer);
});

mymap.on('locationerror', function(e) {
    console.error("Error de ubicaci√≥n:", e.message);
});

// ==============================================
// INICIALIZACI√ìN
// ==============================================

// Dibujar grid inicial
setTimeout(() => {
    dibujarGridFisico();
}, 1000);

console.log("‚úÖ Sistema Postal - VERSI√ìN MEJORADA");
</script>
</body>
</html>



