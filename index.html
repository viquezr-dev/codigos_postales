<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL DE PANAM - POLGONOS IRREGULARES</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 250px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .leaflet-top.leaflet-right { top: 80px !important; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; }
        .micro-label-fixed { background: none!important; border:none!important; color: #3498db!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-label-fixed { background: none!important; border:none!important; color: #2980b9!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 8px; }
        .nano-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .micro-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-polygon { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { fill-opacity: 0.3; }
            50% { fill-opacity: 0.7; }
            100% { fill-opacity: 0.3; }
        }
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }
        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.9);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div id="loading" class="loading-overlay">
    <div class="loading-spinner"></div>
    <p style="margin-top: 20px; color: #2c3e50;">Cargando sistema postal...</p>
</div>

<div class="map-title"><h1>SISTEMA POSTAL DE PANAM - POLGONOS IRREGULARES</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: K4299-KF952-J31">
    <button id="search-btn">IR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
// ==================== CONFIGURACIN INICIAL ====================
const mymap = L.map('mapid').setView([8.50, -80.0], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas
const zonasGeoLayer = L.layerGroup().addTo(mymap);
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const rutasLayer = L.layerGroup().addTo(mymap);
const estafetasPointsLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawZonas = null;
let labelsEnabled = true;
const ALFABETO = "ABCDEFGHJKLMNPQRSTUVWXYZ";
const NANO_RES = 25;

// Cache optimizado
const microCache = new Map(); // Solo guarda cuando se necesita
const nanoCache = new Map();
let hiddenLabels = [];
let updateTimeout = null;

// ==================== FUNCIONES OPTIMIZADAS ====================

// Funci贸n para verificar si un punto est谩 dentro de un pol铆gono (optimizada)
function pointInPolygon(point, polygon) {
    return leafletPip.pointInLayer(point, L.geoJSON(polygon)).length > 0;
}

// Funci贸n para generar c贸digo determinista pero aparentemente aleatorio
function hashPosition(ix, iy, salt) {
    let hash = (ix * 15485863) ^ (iy * 2860486313) ^ (salt * 5915587277);
    hash = (hash * 2654435761) >>> 0;
    return Math.abs(hash % 1000000);
}

// Generar c贸digo nano
function generateNanoCode(nix, niy, microIx, microIy, fid) {
    const salt = (microIx * 24 + microIy) * 1000 + fid;
    const hash = hashPosition(nix, niy, salt);
    const letterIndex = hash % 24;
    const num1 = Math.floor((hash / 24) % 10);
    const num2 = Math.floor((hash / 240) % 10);
    return `${ALFABETO[letterIndex]}${num1}${num2}`;
}

// Generar c贸digo micro
function getMicroCodeFromIndices(ix, iy, fid) {
    const baseCode = `${ALFABETO[ix]}${ALFABETO[iy]}${ix % 10}${iy % 10}`;
    const factor = (Math.floor((ix + iy) / 5) + (fid % 10)) % 10;
    return baseCode + factor;
}

// Calcular centro de celda dentro del bounding box
function getCellCenter(bounds, relX, relY) {
    const lat = bounds.getSouth() + relY * (bounds.getNorth() - bounds.getSouth());
    const lng = bounds.getWest() + relX * (bounds.getEast() - bounds.getWest());
    return [lat, lng];
}

// ==================== ACTUALIZACIN OPTIMIZADA ====================

function updateGridAndLabels() {
    clearTimeout(updateTimeout);
    
    // Usar debouncing para evitar actualizaciones muy frecuentes
    updateTimeout = setTimeout(() => {
        gridLayer.clearLayers();
        labelLayer.clearLayers();
        
        if (!rawZonas) return;
        
        const z = mymap.getZoom();
        const bounds = mymap.getBounds();
        
        // Solo procesar pol铆gonos visibles
        rawZonas.features.forEach((feature, index) => {
            const featureBounds = L.geoJSON(feature).getBounds();
            if (!bounds.intersects(featureBounds)) return;
            
            const vmLevel = feature.properties.VM_LEVEL;
            const fid = feature.properties.fid;
            
            // Labels macro (solo zoom bajo)
            if (z >= 9 && z < 14 && labelsEnabled) {
                const center = featureBounds.getCenter();
                L.marker(center, {
                    icon: L.divIcon({ 
                        className: 'watermark-label-fixed', 
                        html: vmLevel, 
                        iconSize: [60, 20] 
                    })
                }).addTo(labelLayer);
            }
            
            // Dibujar grid solo si est谩 en zoom adecuado
            if (z >= 14) {
                drawGridForFeature(feature, z);
            }
        });
        
        // Limpiar cache viejo
        if (z < 14) {
            microCache.clear();
            nanoCache.clear();
        }
        
    }, 50); // 50ms debounce
}

// Funci贸n optimizada para dibujar grid de un solo pol铆gono
function drawGridForFeature(feature, zoom) {
    const bounds = L.geoJSON(feature).getBounds();
    const fid = feature.properties.fid;
    
    let weight, opacity, color;
    if (zoom >= 14 && zoom < 17) {
        weight = 1.5;
        opacity = 0.6;
        color = '#2980b9';
    } else if (zoom >= 17) {
        weight = 1.0;
        opacity = 0.5;
        color = '#3498db';
    } else {
        return; // No dibujar grid en otros zooms
    }
    
    // Dibujar l铆neas de la cuadr铆cula (optimizado)
    for (let i = 0; i <= 24; i++) {
        const relX = i / 24;
        
        // L铆nea vertical
        const vStart = getCellCenter(bounds, relX, 0);
        const vEnd = getCellCenter(bounds, relX, 1);
        
        // L铆nea horizontal
        const hStart = getCellCenter(bounds, 0, relX);
        const hEnd = getCellCenter(bounds, 1, relX);
        
        L.polyline([vStart, vEnd], {color, weight, opacity}).addTo(gridLayer);
        L.polyline([hStart, hEnd], {color, weight, opacity}).addTo(gridLayer);
    }
}

// ==================== CLIC OPTIMIZADO ====================

mymap.on("click", function (e) {
    selectionLayer.clearLayers();
    restoreHiddenLabels();
    
    if (!rawZonas) return;
    
    const clickedFeatures = leafletPip.pointInLayer(
        [e.latlng.lng, e.latlng.lat], 
        L.geoJSON(rawZonas)
    );

    // rea no definida
    if (clickedFeatures.length === 0) {
        showUndefinedAreaPopup(e.latlng);
        return;
    }

    const feature = clickedFeatures[0].feature;
    const vmLevel = feature.properties.VM_LEVEL;
    const fid = feature.properties.fid;
    
    let titulo = "ZONAS POSTALES";
    let finalCode = vmLevel;
    const z = mymap.getZoom();

    if (z < 14) {
        // Nivel macro
        titulo = "ZONAS POSTALES";
        highlightPolygon(feature, "#1a73e8", 0.3);
        
    } else {
        // Calcular 铆ndices para micro/nano SOLO para este clic (no para todo el mapa)
        const bounds = L.geoJSON(feature).getBounds();
        const relX = (e.latlng.lng - bounds.getWest()) / (bounds.getEast() - bounds.getWest());
        const relY = (e.latlng.lat - bounds.getSouth()) / (bounds.getNorth() - bounds.getSouth());
        
        const safeRelX = Math.min(0.999999, Math.max(0.000001, relX));
        const safeRelY = Math.min(0.999999, Math.max(0.000001, relY));
        
        // ndices micro (0-23)
        const microIx = Math.floor(safeRelX * 24);
        const microIy = Math.floor(safeRelY * 24);
        
        if (z >= 14 && z < 17) {
            // Nivel micro
            titulo = "REA POSTAL";
            const microCode = getMicroCodeFromIndices(microIx, microIy, fid);
            finalCode += `-${microCode}`;
            
            // Calcular y mostrar celda micro
            const microBounds = calculateCellBounds(bounds, microIx, microIy, 24);
            highlightCell(microBounds, microCode, "#3498db", "micro");
            
        } else if (z >= 17) {
            // Nivel nano
            titulo = "CDIGO POSTAL";
            
            // ndices nano dentro de micro (0-24)
            const nix = Math.floor((safeRelX * 24 - microIx) * NANO_RES);
            const niy = Math.floor((safeRelY * 24 - microIy) * NANO_RES);
            
            const microCode = getMicroCodeFromIndices(microIx, microIy, fid);
            const nanoCode = generateNanoCode(nix, niy, microIx, microIy, fid);
            finalCode += `-${microCode}-${nanoCode}`;
            
            // Calcular y mostrar celda nano
            const nanoBounds = calculateCellBounds(bounds, 
                microIx + nix/NANO_RES, 
                microIy + niy/NANO_RES, 
                24 * NANO_RES);
            
            highlightCell(nanoBounds, nanoCode, "#2980b9", "nano");
            
            // Mostrar borde micro para referencia
            const microBounds = calculateCellBounds(bounds, microIx, microIy, 24);
            L.polygon(microBounds, {
                color: "#3498db", 
                weight: 2, 
                fillColor: "transparent",
                dashArray: "5, 5",
                opacity: 0.4
            }).addTo(selectionLayer);
        }
    }

    console.log(`C贸digo postal: ${finalCode}`);
    showPopup(e.latlng, titulo, finalCode, feature);
});

// ==================== FUNCIONES AUXILIARES ====================

function calculateCellBounds(bounds, ix, iy, resolution) {
    const relX1 = ix / resolution;
    const relY1 = iy / resolution;
    const relX2 = (ix + 1) / resolution;
    const relY2 = (iy + 1) / resolution;
    
    return [
        getCellCenter(bounds, relX1, relY1),
        getCellCenter(bounds, relX2, relY1),
        getCellCenter(bounds, relX2, relY2),
        getCellCenter(bounds, relX1, relY2)
    ];
}

function highlightPolygon(feature, color, opacity) {
    L.geoJSON(feature, {
        style: {
            color: color, 
            weight: 4, 
            fillColor: color,
            fillOpacity: opacity,
            className: 'highlighted-polygon'
        }
    }).addTo(selectionLayer);
}

function highlightCell(bounds, code, color, type) {
    L.polygon(bounds, {
        color: color, 
        weight: 3, 
        fillColor: color,
        fillOpacity: 0.5,
        className: 'highlighted-polygon'
    }).addTo(selectionLayer);
    
    const center = [
        (bounds[0][0] + bounds[2][0]) / 2,
        (bounds[0][1] + bounds[2][1]) / 2
    ];
    
    L.marker(center, {
        icon: L.divIcon({ 
            className: `${type}-selection-label`, 
            html: `<div style="background: white; color: ${color}; padding: 2px 5px; border-radius: 3px; border: 2px solid ${color}; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${code}</div>`, 
            iconSize: [45, 22],
            iconAnchor: [22, 11]
        }),
        zIndexOffset: 1000
    }).addTo(selectionLayer);
}

function showUndefinedAreaPopup(latlng) {
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(latlng.lat + 0.0004, latlng.lng);
    
    L.popup({offset: popupOffset, className: 'warning-popup'})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center; padding: 10px;">
                <div style="font-size: 16px; color: #e74c3c; margin-bottom: 5px;">
                    锔 REA NO DEFINIDA
                </div>
                <div style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">
                    Esta ubicaci贸n se encuentra fuera de las zonas postales definidas
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')"> MAPS</button>
                    <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(` Ubicaci贸n fuera del sistema postal\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`)}')"> WS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
}

function showPopup(latlng, titulo, finalCode, feature) {
    const ws = encodeURIComponent(` Mi ubicaci贸n: ${finalCode}\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`);
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(latlng.lat + 0.0004, latlng.lng);
    
    const props = feature.properties;
    const areaKm2 = (props.AREA / 1000000).toFixed(2);
    
    const popup = L.popup({offset: popupOffset})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center;">
                <small>${titulo}</small><br>
                <b style="font-family: monospace; font-size: 16px;">${finalCode}</b><br>
                <div style="font-size: 11px; color: #666; margin: 5px 0; padding: 5px; background: #f8f9fa; border-radius: 3px;">
                    ${props.PROV_NOMB} | rea: ${areaKm2} km虏
                </div>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')"> MAPS</button>
                <button class="btn-ws" onclick="window.open('https://wa.me/?text=${ws}')"> WS</button>
            </div>
        `)
        .openOn(mymap);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
        restoreHiddenLabels();
    });
}

function restoreHiddenLabels() {
    hiddenLabels.forEach(layer => {
        if (layer && typeof layer.setOpacity === 'function') {
            layer.setOpacity(1);
        }
    });
    hiddenLabels = [];
}

// ==================== CARGA DE DATOS ====================

Promise.all([
    $.getJSON("estafetas.geojson"),
    $.getJSON("estafetasl.geojson").catch(() => null),
    $.getJSON("estafetasp.geojson").catch(() => null)
]).then(([zonasData, rutasData, puntosData]) => {
    rawZonas = zonasData;
    
    // Cargar zonas
    L.geoJSON(zonasData, {
        style: {color: "#2c3e50", weight: 1.5, fillOpacity: 0.05}
    }).addTo(zonasGeoLayer);
    
    // Cargar rutas si existen
    if (rutasData) {
        L.geoJSON(rutasData, {style: {color: "#e74c3c", weight: 2}}).addTo(rutasLayer);
    }
    
    // Cargar puntos de estafetas si existen
    if (puntosData) {
        L.geoJSON(puntosData, {
            pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
                radius: 5, 
                color: "#27ae60", 
                fillColor: "#2ecc71", 
                fillOpacity: 1
            })
        }).addTo(estafetasPointsLayer);
    }
    
    // Ocultar pantalla de carga
    document.getElementById('loading').style.display = 'none';
    
    // Inicializar
    updateGridAndLabels();
}).catch(error => {
    console.error("Error cargando datos:", error);
    document.getElementById('loading').innerHTML = 
        '<p style="color: #e74c3c;">Error cargando datos. Verifica la consola.</p>';
});

// ==================== BUSCADOR ====================

document.getElementById('search-btn').addEventListener('click', () => {
    const code = document.getElementById('search-input').value.trim().toUpperCase();
    if (!code || !rawZonas) return;
    
    const parts = code.split('-');
    const vmLevel = parts[0];
    
    // Buscar zona por VM_LEVEL
    let feature = rawZonas.features.find(f => f.properties.VM_LEVEL === vmLevel);
    
    if (feature) {
        selectionLayer.clearLayers();
        restoreHiddenLabels();
        
        const bounds = L.geoJSON(feature).getBounds();
        const zoomLevel = parts.length > 2 ? 18 : parts.length > 1 ? 16 : 12;
        
        // Destacar pol铆gono
        highlightPolygon(feature, "#3498db", 0.3);
        
        // Centrar y hacer zoom
        mymap.fitBounds(bounds, {padding: [50, 50]});
        if (zoomLevel > 12) {
            setTimeout(() => mymap.setZoom(zoomLevel), 300);
        }
    } else {
        alert("C贸digo postal no encontrado: " + code);
    }
});

// ==================== CONTROLES ====================

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = '';
        b.title = "Ubicar mi posici贸n";
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:18}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// Control de capas
L.control.layers(null, {
    "Zonas Postales": zonasGeoLayer,
    "Cuadr铆cula": gridLayer,
    "Rutas": rutasLayer,
    "Estafetas": estafetasPointsLayer,
    "Selecci贸n": selectionLayer,
    "Mi ubicaci贸n": userLocationLayer
}, {collapsed: false}).addTo(mymap);

// Toggle labels
$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    updateGridAndLabels();
});

// Eventos optimizados
mymap.on('moveend zoomend', updateGridAndLabels);
mymap.on('zoomstart movestart', function() {
    selectionLayer.clearLayers();
    restoreHiddenLabels();
});

// GPS
mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    
    L.marker(e.latlng, {
        icon: L.divIcon({
            className: 'user-location-icon',
            html: '',
            iconSize: [30, 30]
        }),
        zIndexOffset: 1000
    }).addTo(userLocationLayer);
});

mymap.on('locationerror', function(e) {
    console.error("Error de ubicaci贸n:", e.message);
});
</script>
</body>
</html>
