<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL DE PANAM√Å</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 250px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .leaflet-top.leaflet-right { top: 80px !important; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; }
        .micro-label-fixed { background: none!important; border:none!important; color: #3498db!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-label-fixed { background: none!important; border:none!important; color: #2980b9!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 8px; }
        .nano-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .micro-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-polygon { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { fill-opacity: 0.3; }
            50% { fill-opacity: 0.7; }
            100% { fill-opacity: 0.3; }
        }
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }
        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        .code-display {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            letter-spacing: 1px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 2px solid #3498db;
            margin: 10px 0;
        }
        .performance-warning {
            position: absolute;
            bottom: 70px;
            left: 10px;
            background: #ffcc00;
            color: #333;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            z-index: 5000;
            display: none;
        }
    </style>
</head>
<body>

<div class="performance-warning" id="perf-warning">üîÑ Calculando...</div>
<div class="map-title"><h1>SISTEMA POSTAL DE PANAM√Å</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: K4299-KF952-J31">
    <button id="search-btn">IR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
// ==================== CONFIGURACI√ìN R√ÅPIDA ====================
const mymap = L.map('mapid').setView([8.50, -80.0], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas M√çNIMAS
const zonasGeoLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawZonas = null;
let labelsEnabled = true;
const ALFABETO = "ABCDEFGHJKLMNPQRSTUVWXYZ";
const NANO_RES = 25;

// Bounds de Panam√° (aproximado)
const PANAMA_BOUNDS = {
    minLng: -83.0,
    maxLng: -77.0,
    minLat: 7.0,
    maxLat: 9.8
};

// Cache simple
let lastZoom = 0;
let lastCenter = null;
let updateTimeout = null;

// ==================== FUNCIONES OPTIMIZADAS ====================

function getMicroCodeFromIndices(ix, iy, fid) {
    return `${ALFABETO[ix]}${ALFABETO[iy]}${(ix + fid) % 10}${(iy + fid) % 10}`;
}

function generateNanoCode(nix, niy, microIx, microIy, fid) {
    const seed = (microIx * 24 + microIy) * 1000 + fid + (nix * NANO_RES + niy);
    const hash = (seed * 2654435761) >>> 0;
    return `${ALFABETO[hash % 24]}${(hash >> 4) % 10}${(hash >> 8) % 10}`;
}

function latLngToIndices(lat, lng) {
    const relX = (lng - PANAMA_BOUNDS.minLng) / (PANAMA_BOUNDS.maxLng - PANAMA_BOUNDS.minLng);
    const relY = (lat - PANAMA_BOUNDS.minLat) / (PANAMA_BOUNDS.maxLat - PANAMA_BOUNDS.minLat);
    
    const safeRelX = Math.max(0.001, Math.min(0.999, relX));
    const safeRelY = Math.max(0.001, Math.min(0.999, relY));
    
    const microIx = Math.floor(safeRelX * 24);
    const microIy = Math.floor(safeRelY * 24);
    const nix = Math.floor((safeRelX * 24 - microIx) * NANO_RES);
    const niy = Math.floor((safeRelY * 24 - microIy) * NANO_RES);
    
    return { microIx, microIy, nix, niy };
}

function indicesToCellBounds(microIx, microIy, isNano = false, nix = 0, niy = 0) {
    const totalCells = isNano ? 24 * NANO_RES : 24;
    const cellSizeX = (PANAMA_BOUNDS.maxLng - PANAMA_BOUNDS.minLng) / totalCells;
    const cellSizeY = (PANAMA_BOUNDS.maxLat - PANAMA_BOUNDS.minLat) / totalCells;
    
    const ix = isNano ? microIx * NANO_RES + nix : microIx;
    const iy = isNano ? microIy * NANO_RES + niy : microIy;
    
    const west = PANAMA_BOUNDS.minLng + ix * cellSizeX;
    const east = west + cellSizeX;
    const south = PANAMA_BOUNDS.minLat + iy * cellSizeY;
    const north = south + cellSizeY;
    
    return [[south, west], [south, east], [north, east], [north, west]];
}

// ==================== ACTUALIZACI√ìN ULTRA-LIGERA ====================

function updateGridAndLabels() {
    clearTimeout(updateTimeout);
    
    // Solo actualizar si hay cambio significativo
    const currentZoom = mymap.getZoom();
    const currentCenter = mymap.getCenter();
    
    if (currentZoom === lastZoom && 
        lastCenter && 
        currentCenter.distanceTo(lastCenter) < 1000) {
        return;
    }
    
    lastZoom = currentZoom;
    lastCenter = currentCenter;
    
    // Mostrar aviso de c√°lculo
    document.getElementById('perf-warning').style.display = 'block';
    
    updateTimeout = setTimeout(() => {
        gridLayer.clearLayers();
        labelLayer.clearLayers();
        
        if (!rawZonas) {
            document.getElementById('perf-warning').style.display = 'none';
            return;
        }
        
        const z = currentZoom;
        
        // ===== ZOOM BAJO (9-13): Solo labels VM_LEVEL =====
        if (z >= 9 && z < 14 && labelsEnabled) {
            const bounds = mymap.getBounds();
            
            // Mostrar m√°ximo 20 labels para no saturar
            let count = 0;
            rawZonas.features.forEach(feature => {
                if (count >= 20) return;
                
                const featureBounds = L.geoJSON(feature).getBounds();
                if (bounds.intersects(featureBounds)) {
                    const center = featureBounds.getCenter();
                    const vmLevel = feature.properties.VM_LEVEL;
                    
                    L.marker(center, {
                        icon: L.divIcon({ 
                            className: 'watermark-label-fixed', 
                            html: vmLevel, 
                            iconSize: [60, 20] 
                        })
                    }).addTo(labelLayer);
                    
                    count++;
                }
            });
        }
        
        // ===== ZOOM MEDIO (14-16): Grid b√°sico =====
        else if (z >= 14 && z < 17) {
            drawBasicGrid(z);
            
            // Opcional: labels micro (muy limitados)
            if (labelsEnabled) {
                addSparseMicroLabels(z);
            }
        }
        
        // ===== ZOOM ALTO (17+): Grid fino =====
        else if (z >= 17) {
            drawFineGrid(z);
        }
        
        // Ocultar aviso
        document.getElementById('perf-warning').style.display = 'none';
        
    }, 100); // 100ms de debounce
}

// Dibujar grid b√°sico (solo l√≠neas principales)
function drawBasicGrid(zoom) {
    const totalCells = 24;
    const cellSizeX = (PANAMA_BOUNDS.maxLng - PANAMA_BOUNDS.minLng) / totalCells;
    const cellSizeY = (PANAMA_BOUNDS.maxLat - PANAMA_BOUNDS.minLat) / totalCells;
    
    const bounds = mymap.getBounds();
    
    // Calcular rango visible
    const startX = Math.max(0, Math.floor((bounds.getWest() - PANAMA_BOUNDS.minLng) / cellSizeX) - 1);
    const endX = Math.min(totalCells, Math.ceil((bounds.getEast() - PANAMA_BOUNDS.minLng) / cellSizeX) + 1);
    const startY = Math.max(0, Math.floor((bounds.getSouth() - PANAMA_BOUNDS.minLat) / cellSizeY) - 1);
    const endY = Math.min(totalCells, Math.ceil((bounds.getNorth() - PANAMA_BOUNDS.minLat) / cellSizeY) + 1);
    
    // Dibujar SOLO las celdas visibles
    for (let i = startX; i <= endX; i++) {
        const lng = PANAMA_BOUNDS.minLng + i * cellSizeX;
        L.polyline([
            [PANAMA_BOUNDS.minLat, lng],
            [PANAMA_BOUNDS.maxLat, lng]
        ], {color: '#3498db', weight: 1, opacity: 0.4}).addTo(gridLayer);
    }
    
    for (let j = startY; j <= endY; j++) {
        const lat = PANAMA_BOUNDS.minLat + j * cellSizeY;
        L.polyline([
            [lat, PANAMA_BOUNDS.minLng],
            [lat, PANAMA_BOUNDS.maxLng]
        ], {color: '#3498db', weight: 1, opacity: 0.4}).addTo(gridLayer);
    }
}

// Dibujar grid fino (para zoom alto)
function drawFineGrid(zoom) {
    const totalCells = 24 * NANO_RES;
    const cellSizeX = (PANAMA_BOUNDS.maxLng - PANAMA_BOUNDS.minLng) / totalCells;
    const cellSizeY = (PANAMA_BOUNDS.maxLat - PANAMA_BOUNDS.minLat) / totalCells;
    
    const bounds = mymap.getBounds();
    
    // Calcular rango visible (cada 5 celdas para no saturar)
    const step = 5;
    const startX = Math.max(0, Math.floor((bounds.getWest() - PANAMA_BOUNDS.minLng) / cellSizeX) - step);
    const endX = Math.min(totalCells, Math.ceil((bounds.getEast() - PANAMA_BOUNDS.minLng) / cellSizeX) + step);
    const startY = Math.max(0, Math.floor((bounds.getSouth() - PANAMA_BOUNDS.minLat) / cellSizeY) - step);
    const endY = Math.min(totalCells, Math.ceil((bounds.getNorth() - PANAMA_BOUNDS.minLat) / cellSizeY) + step);
    
    // Dibujar SOLO las l√≠neas visibles
    for (let i = startX; i <= endX; i += step) {
        const lng = PANAMA_BOUNDS.minLng + i * cellSizeX;
        L.polyline([
            [bounds.getSouth(), lng],
            [bounds.getNorth(), lng]
        ], {color: '#2980b9', weight: 0.5, opacity: 0.2}).addTo(gridLayer);
    }
    
    for (let j = startY; j <= endY; j += step) {
        const lat = PANAMA_BOUNDS.minLat + j * cellSizeY;
        L.polyline([
            [lat, bounds.getWest()],
            [lat, bounds.getEast()]
        ], {color: '#2980b9', weight: 0.5, opacity: 0.2}).addTo(gridLayer);
    }
}

// A√±adir labels micro muy espaciados
function addSparseMicroLabels(zoom) {
    if (!rawZonas) return;
    
    const bounds = mymap.getBounds();
    const step = 3; // Solo cada 3 celdas
    
    for (let i = 0; i < 24; i += step) {
        for (let j = 0; j < 24; j += step) {
            const centerLng = PANAMA_BOUNDS.minLng + (i + 0.5) * (PANAMA_BOUNDS.maxLng - PANAMA_BOUNDS.minLng) / 24;
            const centerLat = PANAMA_BOUNDS.minLat + (j + 0.5) * (PANAMA_BOUNDS.maxLat - PANAMA_BOUNDS.minLat) / 24;
            
            // Solo si est√° en viewport
            if (bounds.contains([centerLat, centerLng])) {
                // Verificar si est√° en pol√≠gono (solo si es necesario)
                const polygons = leafletPip.pointInLayer([centerLng, centerLat], L.geoJSON(rawZonas));
                if (polygons.length > 0) {
                    const fid = polygons[0].feature.properties.fid;
                    const microCode = getMicroCodeFromIndices(i, j, fid);
                    
                    L.marker([centerLat, centerLng], {
                        icon: L.divIcon({ 
                            className: 'micro-label-fixed', 
                            html: microCode, 
                            iconSize: [40, 12] 
                        })
                    }).addTo(labelLayer);
                }
            }
        }
    }
}

// ==================== EVENTO CLIC (OPTIMIZADO) ====================

mymap.on("click", function (e) {
    selectionLayer.clearLayers();
    
    if (!rawZonas) return;
    
    // Verificar r√°pidamente si est√° en pol√≠gono
    const clickedFeatures = leafletPip.pointInLayer(
        [e.latlng.lng, e.latlng.lat], 
        L.geoJSON(rawZonas)
    );

    // Fuera de pol√≠gono = sin c√≥digo
    if (clickedFeatures.length === 0) {
        showUndefinedAreaPopup(e.latlng);
        return;
    }

    // Dentro de pol√≠gono = generar c√≥digo
    processClickInPolygon(e.latlng, clickedFeatures[0].feature);
});

function showUndefinedAreaPopup(latlng) {
    const popup = L.popup()
        .setLatLng([latlng.lat + 0.0004, latlng.lng])
        .setContent(`
            <div style="text-align:center; padding: 10px;">
                <div style="font-size: 16px; color: #e74c3c; margin-bottom: 5px;">
                    ‚ö†Ô∏è √ÅREA NO ASIGNADA
                </div>
                <div style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">
                    Esta ubicaci√≥n no tiene c√≥digo postal
                </div>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç Ubicaci√≥n sin c√≥digo postal\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
            </div>
        `)
        .openOn(mymap);
}

function processClickInPolygon(latlng, feature) {
    const vmLevel = feature.properties.VM_LEVEL;
    const fid = feature.properties.fid;
    const z = mymap.getZoom();
    
    let titulo = "ZONA POSTAL";
    let finalCode = vmLevel;
    
    // Calcular √≠ndices
    const indices = latLngToIndices(latlng.lat, latlng.lng);
    
    if (z < 14) {
        // Solo destacar pol√≠gono
        L.geoJSON(feature, {
            style: {
                color: "#1a73e8", 
                weight: 4, 
                fillColor: "#1a73e8",
                fillOpacity: 0.3
            }
        }).addTo(selectionLayer);
        
    } else if (z >= 14 && z < 17) {
        // Nivel micro
        titulo = "√ÅREA POSTAL";
        const microCode = getMicroCodeFromIndices(indices.microIx, indices.microIy, fid);
        finalCode += `-${microCode}`;
        
        const microBounds = indicesToCellBounds(indices.microIx, indices.microIy);
        highlightCell(microBounds, microCode, "#3498db");
        
    } else {
        // Nivel nano
        titulo = "C√ìDIGO POSTAL";
        const microCode = getMicroCodeFromIndices(indices.microIx, indices.microIy, fid);
        const nanoCode = generateNanoCode(indices.nix, indices.niy, indices.microIx, indices.microIy, fid);
        finalCode += `-${microCode}-${nanoCode}`;
        
        const nanoBounds = indicesToCellBounds(indices.microIx, indices.microIy, true, indices.nix, indices.niy);
        highlightCell(nanoBounds, nanoCode, "#2980b9");
    }
    
    // Mostrar popup
    showCodePopup(latlng, titulo, finalCode, feature);
}

function highlightCell(bounds, code, color) {
    L.polygon(bounds, {
        color: color, 
        weight: 2, 
        fillColor: color,
        fillOpacity: 0.3
    }).addTo(selectionLayer);
    
    const center = [
        (bounds[0][0] + bounds[2][0]) / 2,
        (bounds[0][1] + bounds[2][1]) / 2
    ];
    
    L.marker(center, {
        icon: L.divIcon({ 
            className: 'micro-selection-label', 
            html: `<div style="background: white; color: ${color}; padding: 2px 5px; border-radius: 3px; border: 1px solid ${color}; font-size: 10px;">${code}</div>`, 
            iconSize: [40, 20],
            iconAnchor: [20, 10]
        })
    }).addTo(selectionLayer);
}

function showCodePopup(latlng, titulo, finalCode, feature) {
    const ws = encodeURIComponent(`üìç C√≥digo Postal: ${finalCode}\nGPS: ${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`);
    const props = feature.properties;
    const areaKm2 = props.AREA ? (props.AREA / 1000000).toFixed(1) + ' km¬≤' : '';
    
    const popup = L.popup()
        .setLatLng([latlng.lat + 0.0004, latlng.lng])
        .setContent(`
            <div style="text-align:center; min-width: 200px;">
                <small>${titulo}</small><br>
                <div class="code-display" style="font-size: 16px;">${finalCode}</div>
                ${areaKm2 ? `<div style="font-size: 11px; color: #666; margin: 5px 0;">${props.PROV_NOMB} ‚Ä¢ ${areaKm2}</div>` : ''}
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                <button class="btn-ws" onclick="window.open('https://wa.me/?text=${ws}')">üí¨ WS</button>
            </div>
        `)
        .openOn(mymap);
    
    popup.on('remove', () => selectionLayer.clearLayers());
}

// ==================== CARGA LIGERA ====================

$.getJSON("estafetas.geojson", d => { 
    rawZonas = d; 
    
    // Solo mostrar pol√≠gonos, sin interactividad pesada
    L.geoJSON(d, {
        style: {color: "#2c3e50", weight: 1, fillOpacity: 0.03},
        interactive: false // ¬°IMPORTANTE! Reduce carga
    }).addTo(zonasGeoLayer);
    
    updateGridAndLabels();
});

// ==================== CONTROLES B√ÅSICOS ====================

// Buscador simple
document.getElementById('search-btn').addEventListener('click', () => {
    const code = document.getElementById('search-input').value.trim().toUpperCase();
    if (!code || !rawZonas) return;
    
    const vmLevel = code.split('-')[0];
    const feature = rawZonas.features.find(f => f.properties.VM_LEVEL === vmLevel);
    
    if (feature) {
        selectionLayer.clearLayers();
        const bounds = L.geoJSON(feature).getBounds();
        mymap.fitBounds(bounds, {padding: [50, 50]});
        
        L.geoJSON(feature, {
            style: {color: "#3498db", weight: 3, fillOpacity: 0.2}
        }).addTo(selectionLayer);
    }
});

// GPS simple
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', '', c);
        b.innerHTML = 'üéØ';
        b.style.cssText = 'width:30px;height:30px;line-height:30px;text-align:center;display:block;background:white;border-radius:5px;cursor:pointer;';
        b.onclick = () => mymap.locate({setView:true, maxZoom:16});
        return c;
    }
});
mymap.addControl(new LocateControl());

// Toggle labels
$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    updateGridAndLabels();
});

// Eventos optimizados
let moveTimeout;
mymap.on('moveend', () => {
    clearTimeout(moveTimeout);
    moveTimeout = setTimeout(updateGridAndLabels, 200);
});

mymap.on('zoomend', updateGridAndLabels);

// GPS
mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    L.circleMarker(e.latlng, {
        radius: 8,
        color: '#3498db',
        fillColor: '#3498db',
        fillOpacity: 0.5
    }).addTo(userLocationLayer);
});

// Inicializar
updateGridAndLabels();
</script>
</body>
</html>
