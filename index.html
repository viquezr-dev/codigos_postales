<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL DE PANAM</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 250px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .leaflet-top.leaflet-right { top: 80px !important; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; }
        .micro-label-fixed { background: none!important; border:none!important; color: #3498db!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-label-fixed { background: none!important; border:none!important; color: #2980b9!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 8px; }
        .nano-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .micro-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-polygon { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { fill-opacity: 0.3; }
            50% { fill-opacity: 0.7; }
            100% { fill-opacity: 0.3; }
        }
        
        /* AGREGAR AQU LOS ESTILOS PARA EL POPUP DE ADVERTENCIA */
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }

        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        
        /* Base selector */
        .base-selector {
            position: absolute;
            top: 15px;
            left: 10px;
            z-index: 5000;
            background: white;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: flex;
            gap: 10px;
            align-items: center;
            font-size: 12px;
        }
        
        .base-option {
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            border: 2px solid #ddd;
        }
        
        .base-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.1);
        }
        
        .base-option.selected {
            border-color: #1a73e8;
            background: #1a73e8;
            color: white;
        }
        
        .code-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 5000;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            max-width: 250px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
    
    </style>
</head>
<body>

<div class="map-title"><h1>SISTEMA POSTAL DE PANAM - BASE <span id="current-base">30</span></h1></div>

<!-- Selector de Base -->
<div class="base-selector">
    <span>Base:</span>
    <div class="base-option selected" onclick="setBase(30)">30</div>
    <div class="base-option" onclick="setBase(36)">36</div>
</div>

<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: J4199 o A6299-GT674-A5C">
    <button id="search-btn">IR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>

<!-- Informaci贸n del c贸digo -->
<div class="code-info">
    <strong>Sistema Base <span id="info-base">30</span></strong><br>
    <span id="code-stats">Precisi贸n: ~25m</span>
</div>

<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
// ============================================================================
// CONFIGURACIN GLOBAL DE BASE 30/36
// ============================================================================

let CURRENT_BASE = 30; // 30 o 36

// Alfabetos para cada base
const ALPHABETS = {
    30: "0123456789BCDFGHJKLMNPQRSTVWXYZ", // Base 30 (sin vocales, sin ambig眉edades)
    36: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" // Base 36 completa
};

// Configuraci贸n espec铆fica por base
const BASE_CONFIG = {
    30: {
        microGridSize: 20,  // 20x20 celdas micro (en lugar de 24x24)
        nanoGridSize: 15,   // 15x15 celdas nano por micro
        precision: "~25m",  // Precisi贸n aproximada por celda micro
        characters: 30
    },
    36: {
        microGridSize: 24,  // 24x24 celdas micro
        nanoGridSize: 25,   // 25x25 celdas nano por micro
        precision: "~15m",  // Mayor precisi贸n
        characters: 36
    }
};

// ============================================================================
// INICIALIZACIN DEL MAPA
// ============================================================================

const mymap = L.map('mapid').setView([8.50, -80.0], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas
const zonasGeoLayer = L.layerGroup().addTo(mymap);
const cuadriculaFisicaLayer = L.layerGroup().addTo(mymap);
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const rutasLayer = L.layerGroup().addTo(mymap);
const estafetasPointsLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawCuadricula = null, rawZonas = null;
let labelsEnabled = true;

// CACHE para watermarks micro y nano
const microWatermarkCache = new Map();
const nanoWatermarkCache = new Map();

// Variable para almacenar labels temporales que se deben restaurar
let hiddenLabels = [];

// ============================================================================
// FUNCIONES DE CODIFICACIN CON BASE 30/36
// ============================================================================

// Obtener alfabeto actual
function getAlphabet() {
    return ALPHABETS[CURRENT_BASE];
}

// Obtener configuraci贸n actual
function getConfig() {
    return BASE_CONFIG[CURRENT_BASE];
}

// Funci贸n hash mejorada para generar c贸digos desordenados
function hashPosition(ix, iy, salt = 0) {
    let hash = (ix * 15485863) ^ (iy * 2860486313) ^ (salt * 5915587277);
    hash = (hash * 2654435761) >>> 0;
    return Math.abs(hash % 1000000);
}

// Generar c贸digo micro seg煤n base
function generateMicroCode(ix, iy) {
    const config = getConfig();
    const alphabet = getAlphabet();
    
    // Base 30: Formato m谩s compacto (2 caracteres)
    if (CURRENT_BASE === 30) {
        const firstChar = alphabet[ix % 30];
        const secondChar = alphabet[iy % 30];
        return `${firstChar}${secondChar}`;
    }
    // Base 36: Formato de 3 caracteres (m谩s informaci贸n)
    else {
        const firstChar = alphabet[ix % 36];
        const secondChar = alphabet[iy % 36];
        const checkDigit = alphabet[(ix + iy) % 36]; // D铆gito verificador
        return `${firstChar}${secondChar}${checkDigit}`;
    }
}

// Generar c贸digo nano seg煤n base
function generateNanoCode(nix, niy, microIx, microIy) {
    const config = getConfig();
    const alphabet = getAlphabet();
    const salt = microIx * config.microGridSize + microIy;
    const hash = hashPosition(nix, niy, salt);
    
    // Base 30: 2 caracteres
    if (CURRENT_BASE === 30) {
        const char1 = alphabet[Math.floor(hash / 1000) % 30];
        const char2 = alphabet[hash % 30];
        return `${char1}${char2}`;
    }
    // Base 36: 3 caracteres
    else {
        const char1 = alphabet[Math.floor(hash / 1296) % 36]; // 36^2 = 1296
        const char2 = alphabet[Math.floor(hash / 36) % 36];
        const char3 = alphabet[hash % 36];
        return `${char1}${char2}${char3}`;
    }
}

// Funci贸n para decodificar micro (inversa)
function decodeMicroCode(code) {
    const alphabet = getAlphabet();
    if (CURRENT_BASE === 30 && code.length === 2) {
        const ix = alphabet.indexOf(code[0]);
        const iy = alphabet.indexOf(code[1]);
        return { ix, iy };
    } else if (CURRENT_BASE === 36 && code.length === 3) {
        const ix = alphabet.indexOf(code[0]);
        const iy = alphabet.indexOf(code[1]);
        // El tercer car谩cter es verificador, lo ignoramos para decodificar posici贸n
        return { ix, iy };
    }
    return null;
}

// ============================================================================
// FUNCIONES AUXILIARES
// ============================================================================

function getPointInGrid(coords, col, row, totalCols, totalRows) {
    const p0 = coords[0], p1 = coords[1], p2 = coords[2], p3 = coords[3];
    const tX = col / totalCols, tY = row / totalRows;
    const lat = (1-tY)*((1-tX)*p0[1] + tX*p1[1]) + tY*((1-tX)*p3[1] + tX*p2[1]);
    const lng = (1-tY)*((1-tX)*p0[0] + tX*p1[0]) + tY*((1-tX)*p3[0] + tX*p2[0]);
    return [lat, lng];
}

function getCacheKey(featureId, level, i, j, ni = null, nj = null) {
    if (ni !== null && nj !== null) {
        return `f${featureId}-${level}-${i}-${j}-${ni}-${nj}`;
    }
    return `f${featureId}-${level}-${i}-${j}`;
}

// Funci贸n para encontrar watermark m谩s cercano
function findClosestWatermark(clickLatLng, watermarkCache, maxDistance = 0.001) {
    let closestWatermark = null;
    let minDistance = Infinity;
    let closestKey = null;
    
    watermarkCache.forEach((watermark, key) => {
        const dx = clickLatLng.lng - watermark.center[1];
        const dy = clickLatLng.lat - watermark.center[0];
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance < minDistance && distance < maxDistance) {
            minDistance = distance;
            closestWatermark = watermark;
            closestKey = key;
        }
    });
    
    return closestWatermark;
}

// Funci贸n para calcular en qu茅 celda nano est谩 un punto dado
function calculateNanoIndicesFromPoint(lat, lng, feature, microWatermark) {
    const b = L.geoJSON(feature).getBounds();
    const coords = feature.geometry.coordinates[0];
    const config = getConfig();
    
    const relX = (lng - b.getWest()) / (b.getEast() - b.getWest());
    const relY = (lat - b.getSouth()) / (b.getNorth() - b.getSouth());
    
    const safeRelX = Math.min(0.9999999, Math.max(0.0000001, relX));
    const safeRelY = Math.min(0.9999999, Math.max(0.0000001, relY));
    
    const microIx = Math.floor(safeRelX * config.microGridSize);
    const microIy = Math.floor(safeRelY * config.microGridSize);
    
    const cellRelX = (safeRelX * config.microGridSize) - microIx;
    const cellRelY = (safeRelY * config.microGridSize) - microIy;
    
    const nix = Math.floor(cellRelX * config.nanoGridSize);
    const niy = Math.floor(cellRelY * config.nanoGridSize);
    
    return {
        microIx: Math.min(config.microGridSize-1, Math.max(0, microIx)),
        microIy: Math.min(config.microGridSize-1, Math.max(0, microIy)),
        nix: Math.min(config.nanoGridSize-1, Math.max(0, nix)),
        niy: Math.min(config.nanoGridSize-1, Math.max(0, niy))
    };
}

// ============================================================================
// ACTUALIZACIN DE GRID Y LABELS
// ============================================================================

function updateGridAndLabels() {
    gridLayer.clearLayers();
    labelLayer.clearLayers();
    microWatermarkCache.clear();
    nanoWatermarkCache.clear();
    hiddenLabels = [];
    
    if (!rawCuadricula) return;
    
    const z = mymap.getZoom();
    const bounds = mymap.getBounds();
    const config = getConfig();

    rawCuadricula.features.forEach((f, featureIndex) => {
        const fBounds = L.geoJSON(f).getBounds();
        if (!bounds.intersects(fBounds)) return;
        
        const coords = f.geometry.coordinates[0];
        
        // Labels para macro (zoom 10-14)
        if (z >= 10 && z < 14 && labelsEnabled) {
            L.marker(fBounds.getCenter(), {
                icon: L.divIcon({ 
                    className: 'watermark-label-fixed', 
                    html: f.properties.codigo, 
                    iconSize: [60, 20] 
                })
            }).addTo(labelLayer);
        }
        
        // Labels y cache para micro
        const microSize = config.microGridSize;
        for (let i = 0; i < microSize; i++) {
            for (let j = 0; j < microSize; j++) {
                const center = getPointInGrid(coords, i + 0.5, j + 0.5, microSize, microSize);
                const microCode = generateMicroCode(i, j);
                
                const cacheKey = getCacheKey(featureIndex, 'micro', i, j);
                microWatermarkCache.set(cacheKey, {
                    center: center,
                    code: microCode,
                    bounds: [
                        getPointInGrid(coords, i, j, microSize, microSize),
                        getPointInGrid(coords, i+1, j, microSize, microSize),
                        getPointInGrid(coords, i+1, j+1, microSize, microSize),
                        getPointInGrid(coords, i, j+1, microSize, microSize)
                    ],
                    indices: { ix: i, iy: j }
                });
                
                if (z >= 14 && z < 17 && labelsEnabled) {
                    L.marker(center, {
                        icon: L.divIcon({ 
                            className: 'micro-label-fixed', 
                            html: microCode, 
                            iconSize: [45, 15] 
                        })
                    }).addTo(labelLayer);
                }
            }
        }
        
        // Cache para nano (zoom >= 17)
        if (z >= 17) {
            const nanoSize = config.nanoGridSize;
            for (let i = 0; i < microSize; i++) {
                for (let j = 0; j < microSize; j++) {
                    for (let ni = 0; ni < nanoSize; ni++) {
                        for (let nj = 0; nj < nanoSize; nj++) {
                            const nanoCenter = getPointInGrid(coords, 
                                i + (ni + 0.5)/nanoSize, 
                                j + (nj + 0.5)/nanoSize, 
                                microSize, microSize);
                            
                            if (bounds.contains(nanoCenter)) {
                                const nanoCode = generateNanoCode(ni, nj, i, j);
                                
                                const cacheKey = getCacheKey(featureIndex, 'nano', i, j, ni, nj);
                                nanoWatermarkCache.set(cacheKey, {
                                    center: nanoCenter,
                                    code: nanoCode,
                                    bounds: [
                                        getPointInGrid(coords, i + ni/nanoSize, j + nj/nanoSize, microSize, microSize),
                                        getPointInGrid(coords, i + (ni+1)/nanoSize, j + nj/nanoSize, microSize, microSize),
                                        getPointInGrid(coords, i + (ni+1)/nanoSize, j + (nj+1)/nanoSize, microSize, microSize),
                                        getPointInGrid(coords, i + ni/nanoSize, j + (nj+1)/nanoSize, microSize, microSize)
                                    ],
                                    indices: { microIx: i, microIy: j, nix: ni, niy: nj }
                                });
                                
                                // Mostrar solo algunos labels nano para no saturar
                                if (labelsEnabled && ni % 5 === 0 && nj % 5 === 0) {
                                    L.marker(nanoCenter, {
                                        icon: L.divIcon({ 
                                            className: 'nano-label-fixed', 
                                            html: nanoCode, 
                                            iconSize: [35, 10] 
                                        })
                                    }).addTo(labelLayer);
                                }
                            }
                        }
                    }
                }
            }
        }

        // REJILLA DINMICA
        if (z >= 14 && mymap.hasLayer(gridLayer)) {
            const microSize = config.microGridSize;
            
            // L铆neas principales MICRO
            for (let i = 0; i <= microSize; i++) {
                let v = [], h = [];
                for(let j = 0; j <= microSize; j++) {
                    v.push(getPointInGrid(coords, i, j, microSize, microSize));
                    h.push(getPointInGrid(coords, j, i, microSize, microSize));
                }
                
                let weight, opacity, color;
                if (z >= 14 && z < 17) {
                    weight = 1.8;
                    opacity = 0.7;
                    color = '#2980b9';
                } else {
                    weight = 1.0;
                    opacity = 0.6;
                    color = '#3498db';
                }
                
                L.polyline(v, {color: color, weight: weight, opacity: opacity}).addTo(gridLayer);
                L.polyline(h, {color: color, weight: weight, opacity: opacity}).addTo(gridLayer);
            }
            
            // L铆neas NANO
            if (z >= 17) {
                const nanoSize = config.nanoGridSize;
                for (let i = 0; i < microSize; i++) {
                    for (let j = 0; j < microSize; j++) {
                        const topLeft = getPointInGrid(coords, i, j, microSize, microSize);
                        const topRight = getPointInGrid(coords, i+1, j, microSize, microSize);
                        const bottomRight = getPointInGrid(coords, i+1, j+1, microSize, microSize);
                        const bottomLeft = getPointInGrid(coords, i, j+1, microSize, microSize);
                        
                        // L铆neas verticales NANO
                        for (let ni = 1; ni < nanoSize; ni++) {
                            const t = ni / nanoSize;
                            const p1 = [
                                (1-t) * topLeft[0] + t * topRight[0],
                                (1-t) * topLeft[1] + t * topRight[1]
                            ];
                            const p2 = [
                                (1-t) * bottomLeft[0] + t * bottomRight[0],
                                (1-t) * bottomLeft[1] + t * bottomRight[1]
                            ];
                            L.polyline([p1, p2], {
                                color: '#2980b9',
                                weight: 0.6,
                                opacity: 0.4,
                                dashArray: '3,2'
                            }).addTo(gridLayer);
                        }
                        
                        // L铆neas horizontales NANO
                        for (let nj = 1; nj < nanoSize; nj++) {
                            const t = nj / nanoSize;
                            const p1 = [
                                (1-t) * topLeft[0] + t * bottomLeft[0],
                                (1-t) * topLeft[1] + t * bottomLeft[1]
                            ];
                            const p2 = [
                                (1-t) * topRight[0] + t * bottomRight[0],
                                (1-t) * topRight[1] + t * bottomRight[1]
                            ];
                            L.polyline([p1, p2], {
                                color: '#2980b9',
                                weight: 0.6,
                                opacity: 0.4,
                                dashArray: '3,2'
                            }).addTo(gridLayer);
                        }
                    }
                }
            }
        }
    });
    
    updateCodeInfo();
}

// ============================================================================
// EVENTO CLIC EN MAPA
// ============================================================================

mymap.on("click", function (e) {
    selectionLayer.clearLayers();
    restoreHiddenLabels();
    hiddenLabels = [];
    
    if (!rawCuadricula || !rawZonas) return;
    
    const hZ = leafletPip.pointInLayer([e.latlng.lng, e.latlng.lat], L.geoJSON(rawZonas));
    const hC = leafletPip.pointInLayer([e.latlng.lng, e.latlng.lat], L.geoJSON(rawCuadricula));

    // VERIFICAR SI EST EN REA NO DEFINIDA
    if (hC.length === 0) {
        const popupOffset = [0, -60];
        const popupLatLng = L.latLng(e.latlng.lat + 0.0004, e.latlng.lng);
        
        L.popup({offset: popupOffset, className: 'warning-popup'})
            .setLatLng(popupLatLng)
            .setContent(`
                <div style="text-align:center; padding: 10px;">
                    <div style="font-size: 16px; color: #e74c3c; margin-bottom: 5px;">
                        锔 REA NO DEFINIDA
                    </div>
                    <div style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">
                        Esta ubicaci贸n se encuentra fuera de las zonas postales definidas
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${e.latlng.lat},${e.latlng.lng}')"> MAPS</button>
                        <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(` Ubicaci贸n fuera del sistema postal\nGPS: ${e.latlng.lat.toFixed(6)},${e.latlng.lng.toFixed(6)}`)}')"> WS</button>
                    </div>
                </div>
            `)
            .openOn(mymap);
        return;
    }

    const useZonas = mymap.hasLayer(zonasGeoLayer) && hZ.length > 0;
    const macroID = useZonas ? hZ[0].feature.properties.VM_LEVEL : hC[0].feature.properties.codigo;
    
    let titulo = "ZONAS POSTALES", finalCode = macroID;
    const z = mymap.getZoom();
    const featureIndex = rawCuadricula.features.findIndex(f => f === hC[0].feature);

    if (z < 14) {
        // Nivel macro
        titulo = "ZONAS POSTALES";
        const selectedFeature = useZonas ? hZ[0].feature : hC[0].feature;
        L.geoJSON(selectedFeature, {
            style: {
                color: "#1a73e8", 
                weight: 4, 
                fillColor: "#1a73e8",
                fillOpacity: 0.3,
                className: 'highlighted-polygon'
            }
        }).addTo(selectionLayer);
        
    } else if (z >= 14 && z < 17) {
        // NIVEL MICRO
        titulo = "REA POSTAL";
        const closestWatermark = findClosestWatermark(e.latlng, microWatermarkCache, 0.01);
        
        if (closestWatermark) {
            finalCode += `-${closestWatermark.code}`;
            
            L.polygon(closestWatermark.bounds, {
                color: "#3498db", 
                weight: 3, 
                fillColor: "#3498db",
                fillOpacity: 0.5,
                className: 'highlighted-polygon'
            }).addTo(selectionLayer);
            
            L.marker(closestWatermark.center, {
                icon: L.divIcon({ 
                    className: 'micro-selection-label', 
                    html: `<div style="background: rgba(255,255,255,0.95); color: #3498db; padding: 2px 5px; border-radius: 3px; border: 2px solid #3498db; font-weight: bold;">${closestWatermark.code}</div>`, 
                    iconSize: [50, 22],
                    iconAnchor: [25, 11]
                }),
                zIndexOffset: 1000
            }).addTo(selectionLayer);
        }
        
    } else {
        // NIVEL NANO
        titulo = "CDIGO POSTAL";
        
        const closestWatermark = findClosestWatermark(e.latlng, nanoWatermarkCache, 0.002);
        
        if (closestWatermark) {
            const microKey = getCacheKey(featureIndex, 'micro', 
                closestWatermark.indices.microIx, 
                closestWatermark.indices.microIy);
            const microWatermark = microWatermarkCache.get(microKey);
            const microCode = microWatermark ? microWatermark.code : generateMicroCode(
                closestWatermark.indices.microIx, 
                closestWatermark.indices.microIy
            );
            
            finalCode += `-${microCode}-${closestWatermark.code}`;
            
            // Mostrar cuadro nano
            L.polygon(closestWatermark.bounds, {
                color: "#2980b9", 
                weight: 3, 
                fillColor: "#2980b9",
                fillOpacity: 0.5,
                className: 'highlighted-polygon'
            }).addTo(selectionLayer);
            
            // Ocultar label permanente temporalmente
            labelLayer.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    const markerLatLng = layer.getLatLng();
                    const distance = markerLatLng.distanceTo(closestWatermark.center);
                    if (distance < 5) {
                        layer.setOpacity(0);
                        hiddenLabels.push(layer);
                    }
                }
            });
            
            // Mostrar marcador de selecci贸n
            L.marker(closestWatermark.center, {
                icon: L.divIcon({ 
                    className: 'nano-selection-label', 
                    html: `<div style="background: white; color: #2980b9; padding: 2px 5px; border-radius: 3px; border: 2px solid #2980b9; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${closestWatermark.code}</div>`, 
                    iconSize: [45, 22],
                    iconAnchor: [22, 11]
                }),
                zIndexOffset: 1000
            }).addTo(selectionLayer);
            
            // Mostrar borde micro para referencia
            if (microWatermark) {
                L.polygon(microWatermark.bounds, {
                    color: "#3498db", 
                    weight: 2, 
                    fillColor: "transparent",
                    dashArray: "5, 5",
                    opacity: 0.4
                }).addTo(selectionLayer);
            }
        } else {
            // FALLBACK: Calcular manualmente
            const indices = calculateNanoIndicesFromPoint(e.latlng.lat, e.latlng.lng, hC[0].feature);
            const microCode = generateMicroCode(indices.microIx, indices.microIy);
            const nanoCode = generateNanoCode(indices.nix, indices.niy, indices.microIx, indices.microIy);
            
            finalCode += `-${microCode}-${nanoCode}`;
            
            const coords = hC[0].feature.geometry.coordinates[0];
            const config = getConfig();
            const nanoSize = config.nanoGridSize;
            
            const nanoBounds = [
                getPointInGrid(coords, indices.microIx + indices.nix/nanoSize, indices.microIy + indices.niy/nanoSize, config.microGridSize, config.microGridSize),
                getPointInGrid(coords, indices.microIx + (indices.nix+1)/nanoSize, indices.microIy + indices.niy/nanoSize, config.microGridSize, config.microGridSize),
                getPointInGrid(coords, indices.microIx + (indices.nix+1)/nanoSize, indices.microIy + (indices.niy+1)/nanoSize, config.microGridSize, config.microGridSize),
                getPointInGrid(coords, indices.microIx + indices.nix/nanoSize, indices.microIy + (indices.niy+1)/nanoSize, config.microGridSize, config.microGridSize)
            ];
            
            const nanoCenter = getPointInGrid(coords, 
                indices.microIx + (indices.nix + 0.5)/nanoSize,
                indices.microIy + (indices.niy + 0.5)/nanoSize,
                config.microGridSize, config.microGridSize
            );
            
            L.polygon(nanoBounds, {
                color: "#2980b9", 
                weight: 3, 
                fillColor: "#2980b9",
                fillOpacity: 0.5,
                className: 'highlighted-polygon'
            }).addTo(selectionLayer);
            
            // Ocultar label permanente si existe
            labelLayer.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    const markerLatLng = layer.getLatLng();
                    const distance = markerLatLng.distanceTo(nanoCenter);
                    if (distance < 5) {
                        layer.setOpacity(0);
                        hiddenLabels.push(layer);
                    }
                }
            });
            
            L.marker(nanoCenter, {
                icon: L.divIcon({ 
                    className: 'nano-selection-label', 
                    html: `<div style="background: white; color: #2980b9; padding: 2px 5px; border-radius: 3px; border: 2px solid #2980b9; font-weight: bold;">${nanoCode}</div>`, 
                    iconSize: [45, 22],
                    iconAnchor: [22, 11]
                }),
                zIndexOffset: 1000
            }).addTo(selectionLayer);
        }
    }
    
    const ws = encodeURIComponent(` Mi ubicaci贸n: ${finalCode}\nGPS: ${e.latlng.lat.toFixed(6)},${e.latlng.lng.toFixed(6)}`);
    
    const popupOffset = [0, -60];
    const popupLatLng = L.latLng(e.latlng.lat + 0.0004, e.latlng.lng);
    
    const popup = L.popup({offset: popupOffset})
        .setLatLng(popupLatLng)
        .setContent(`
            <div style="text-align:center;">
                <small>${titulo}</small><br>
                <b>${finalCode}</b><br>
                <small style="color:#666;">Base: ${CURRENT_BASE}</small><br>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${e.latlng.lat},${e.latlng.lng}')"> MAPS</button>
                <button class="btn-ws" onclick="window.open('https://wa.me/?text=${ws}')"> WS</button>
            </div>
        `)
        .openOn(mymap);
    
    popup.on('remove', function() {
        selectionLayer.clearLayers();
        restoreHiddenLabels();
    });
});

// ============================================================================
// FUNCIONES AUXILIARES
// ============================================================================

function restoreHiddenLabels() {
    hiddenLabels.forEach(layer => {
        if (layer && typeof layer.setOpacity === 'function') {
            layer.setOpacity(1);
        }
    });
    hiddenLabels = [];
}

// Cambiar base
function setBase(base) {
    if (CURRENT_BASE !== base) {
        CURRENT_BASE = base;
        
        // Actualizar UI
        document.getElementById('current-base').textContent = base;
        document.getElementById('info-base').textContent = base;
        
        // Actualizar selector visual
        document.querySelectorAll('.base-option').forEach(el => {
            el.classList.remove('selected');
            if (parseInt(el.textContent) === base) {
                el.classList.add('selected');
            }
        });
        
        // Limpiar y regenerar
        microWatermarkCache.clear();
        nanoWatermarkCache.clear();
        updateGridAndLabels();
    }
}

// Actualizar informaci贸n del c贸digo
function updateCodeInfo() {
    const config = getConfig();
    const totalCells = Math.pow(config.microGridSize, 2) * Math.pow(config.nanoGridSize, 2);
    document.getElementById('code-stats').textContent = 
        `Precisi贸n: ${config.precision} | Celdas: ${totalCells.toLocaleString()}`;
}

// ============================================================================
// BUSCADOR
// ============================================================================

document.getElementById('search-btn').addEventListener('click', () => {
    const code = document.getElementById('search-input').value.trim().toUpperCase();
    if (!code || !rawCuadricula) return;
    
    const parts = code.split('-');
    const macroPart = parts[0];
    let f = rawCuadricula.features.find(feat => feat.properties.codigo === macroPart);
    
    if (f) {
        if (parts.length > 1) {
            const microPart = parts[1];
            const decoded = decodeMicroCode(microPart);
            
            if (decoded && decoded.ix !== -1 && decoded.iy !== -1) {
                const config = getConfig();
                const coords = f.geometry.coordinates[0];
                const center = getPointInGrid(coords, 
                    decoded.ix + 0.5, 
                    decoded.iy + 0.5, 
                    config.microGridSize, 
                    config.microGridSize);
                
                const zoomLevel = parts.length > 2 ? 18 : 16;
                mymap.setView(center, zoomLevel);
                
                selectionLayer.clearLayers();
                restoreHiddenLabels();
                
                const mRect = [
                    getPointInGrid(coords, decoded.ix, decoded.iy, config.microGridSize, config.microGridSize),
                    getPointInGrid(coords, decoded.ix+1, decoded.iy, config.microGridSize, config.microGridSize),
                    getPointInGrid(coords, decoded.ix+1, decoded.iy+1, config.microGridSize, config.microGridSize),
                    getPointInGrid(coords, decoded.ix, decoded.iy+1, config.microGridSize, config.microGridSize)
                ];
                
                const microCode = generateMicroCode(decoded.ix, decoded.iy);
                
                L.polygon(mRect, {
                    color: "#3498db", 
                    weight: 3, 
                    fillColor: "#3498db",
                    fillOpacity: 0.5,
                    className: 'highlighted-polygon'
                }).addTo(selectionLayer);
                
                L.marker(center, {
                    icon: L.divIcon({ 
                        className: 'micro-label-fixed', 
                        html: microCode, 
                        iconSize: [60, 18] 
                    })
                }).addTo(selectionLayer);
                
                return;
            }
        }
        
        mymap.fitBounds(L.geoJSON(f).getBounds(), {padding: [50, 50]});
    } else {
        alert("C贸digo postal no encontrado: " + code);
    }
});

// ============================================================================
// CARGAR DATOS Y CONFIGURAR CONTROLES
// ============================================================================

// Carga de Datos
$.getJSON("cuadricula.geojson", d => { 
    rawCuadricula = d; 
    L.geoJSON(d, {style: {color: "#3498db", weight: 1, fillOpacity: 0.05}}).addTo(cuadriculaFisicaLayer);
    updateGridAndLabels(); 
});
$.getJSON("estafetas.geojson", d => { 
    rawZonas = d; 
    L.geoJSON(d, {style: {color: "#2c3e50", weight: 1.5, fillOpacity: 0.05}}).addTo(zonasGeoLayer); 
});
$.getJSON("estafetasl.geojson", d => L.geoJSON(d, {style: {color: "#e74c3c", weight: 2}}).addTo(rutasLayer));
$.getJSON("estafetasp.geojson", d => L.geoJSON(d, {pointToLayer:(f,ll)=>L.circleMarker(ll,{radius:5, color:"#27ae60", fillColor:"#2ecc71", fillOpacity:1})}).addTo(estafetasPointsLayer));

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = '';
        b.title = "Ubicar mi posici贸n";
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:18}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// CONTROL DE CAPAS
L.control.layers(null, {
    "Zonas": zonasGeoLayer,
    "Cuadr铆cula": cuadriculaFisicaLayer,
    "Rutas": rutasLayer,
    "Estafetas": estafetasPointsLayer,
    "C贸digo postal": gridLayer,
    "Selecci贸n": selectionLayer,
    "Mi ubicaci贸n": userLocationLayer
}, {collapsed: false}).addTo(mymap);

$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    updateGridAndLabels();
});

mymap.on('moveend zoomend', updateGridAndLabels);

mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    
    L.marker(e.latlng, {
        icon: L.divIcon({
            className: 'user-location-icon',
            html: '',
            iconSize: [30, 30]
        }),
        zIndexOffset: 1000
    }).addTo(userLocationLayer);
    
    L.circle(e.latlng, {
        radius: e.accuracy / 2,
        color: '#3498db',
        fillColor: '#3498db',
        fillOpacity: 0.1,
        weight: 1
    }).addTo(userLocationLayer);
});

mymap.on('locationerror', function(e) {
    console.error("Error de ubicaci贸n:", e.message);
});

mymap.on('zoomstart movestart', function() {
    selectionLayer.clearLayers();
    restoreHiddenLabels();
});

// Inicializar
updateGridAndLabels();
</script>
</body>
</html>
