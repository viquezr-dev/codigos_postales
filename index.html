<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL PANAM√Å - Base32</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 300px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; }
        .micro-label-fixed { background: none!important; border:none!important; color: #3498db!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-label-fixed { background: none!important; border:none!important; color: #2980b9!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 8px; }
        .nano-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .micro-selection-label { background: none!important; border: none!important; text-align: center; pointer-events: none!important; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-polygon { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { fill-opacity: 0.3; }
            50% { fill-opacity: 0.7; }
            100% { fill-opacity: 0.3; }
        }
        .warning-popup .leaflet-popup-content-wrapper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }
        .warning-popup .leaflet-popup-tip {
            background: #ffc107;
        }
        .code-display {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            color: #2c3e50;
            letter-spacing: 1px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 2px solid #3498db;
            margin: 10px 0;
            text-align: center;
        }
        .info-box {
            font-size: 11px;
            color: #666;
            background: #f1f8ff;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            border-left: 3px solid #3498db;
        }
        .performance-warning {
            position: absolute;
            bottom: 70px;
            left: 10px;
            background: #ffcc00;
            color: #333;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            z-index: 5000;
            display: none;
        }
    </style>
</head>
<body>

<div class="performance-warning" id="perf-warning">üîÑ Calculando...</div>
<div class="map-title"><h1>SISTEMA POSTAL PANAM√Å - Base32</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: K4299-8A9B-X3Y7">
    <button id="search-btn">BUSCAR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
// ==================== CONFIGURACI√ìN R√ÅPIDA ====================
const mymap = L.map('mapid').setView([8.50, -80.0], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas
const zonasGeoLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawZonas = null;
let labelsEnabled = true;

// ==================== SISTEMA BASE32 (MISMA PRECISI√ìN) ====================

// Base32 optimizada (sin caracteres confusos)
const BASE32 = "23456789ABCDEFGHJKMNPQRSTUVWXYZ"; // 32 caracteres

// Configuraci√≥n de tu sistema original:
const MICRO_RES = 24;  // 24√ó24 celdas micro
const NANO_RES = 25;   // 25√ó25 nano por micro

// Funci√≥n para codificar n√∫mero a Base32 (2 caracteres = 0-1023)
function encodeBase32(num, length = 2) {
    let result = '';
    for (let i = 0; i < length; i++) {
        result = BASE32[num % 32] + result;
        num = Math.floor(num / 32);
    }
    return result;
}

// Funci√≥n para decodificar Base32
function decodeBase32(str) {
    const map = {};
    for (let i = 0; i < BASE32.length; i++) {
        map[BASE32[i]] = i;
    }
    
    let result = 0;
    for (let i = 0; i < str.length; i++) {
        result = result * 32 + (map[str[i]] || 0);
    }
    return result;
}

// ==================== FUNCIONES DE C√ìDIGO ====================

// Obtener VM_LEVEL del pol√≠gono donde est√° el punto
function getVMLevelFromPoint(lat, lng, polygons) {
    const point = [lng, lat];
    for (let polygon of polygons) {
        if (leafletPip.pointInLayer(point, L.geoJSON(polygon)).length > 0) {
            return polygon.properties.VM_LEVEL;
        }
    }
    return null;
}

// Calcular √≠ndices micro (0-23) dentro del bounding box del pol√≠gono
function calculateMicroIndices(lat, lng, polygon) {
    const bounds = L.geoJSON(polygon).getBounds();
    
    // Posici√≥n relativa dentro del bounding box
    const relX = (lng - bounds.getWest()) / (bounds.getEast() - bounds.getWest());
    const relY = (lat - bounds.getSouth()) / (bounds.getNorth() - bounds.getSouth());
    
    const safeRelX = Math.max(0.001, Math.min(0.999, relX));
    const safeRelY = Math.max(0.001, Math.min(0.999, relY));
    
    // √çndices micro (0-23)
    const microIx = Math.floor(safeRelX * MICRO_RES);
    const microIy = Math.floor(safeRelY * MICRO_RES);
    
    return { microIx: Math.min(23, microIx), microIy: Math.min(23, microIy) };
}

// Calcular √≠ndices nano (0-24) dentro de micro
function calculateNanoIndices(lat, lng, polygon, microIx, microIy) {
    const bounds = L.geoJSON(polygon).getBounds();
    
    const relX = (lng - bounds.getWest()) / (bounds.getEast() - bounds.getWest());
    const relY = (lat - bounds.getSouth()) / (bounds.getNorth() - bounds.getSouth());
    
    const safeRelX = Math.max(0.001, Math.min(0.999, relX));
    const safeRelY = Math.max(0.001, Math.min(0.999, relY));
    
    // Posici√≥n dentro de la celda micro
    const microRelX = safeRelX * MICRO_RES - microIx;
    const microRelY = safeRelY * MICRO_RES - microIy;
    
    // √çndices nano (0-24)
    const nix = Math.floor(microRelX * NANO_RES);
    const niy = Math.floor(microRelY * NANO_RES);
    
    return { nix: Math.min(24, nix), niy: Math.min(24, niy) };
}

// Generar c√≥digo completo (igual precisi√≥n que tu sistema)
function generatePostalCode(lat, lng) {
    if (!rawZonas) return null;
    
    const point = [lng, lat];
    const polygons = leafletPip.pointInLayer(point, L.geoJSON(rawZonas));
    
    if (polygons.length === 0) return null;
    
    const polygon = polygons[0].feature;
    const vmLevel = polygon.properties.VM_LEVEL;
    
    // Calcular √≠ndices micro
    const microIndices = calculateMicroIndices(lat, lng, polygon);
    
    // Calcular √≠ndices nano
    const nanoIndices = calculateNanoIndices(lat, lng, polygon, 
        microIndices.microIx, microIndices.microIy);
    
    // Codificar en Base32
    const microCode = encodeBase32(microIndices.microIx) + encodeBase32(microIndices.microIy);
    const nanoCode = encodeBase32(nanoIndices.nix) + encodeBase32(nanoIndices.niy);
    
    return {
        fullCode: `${vmLevel}-${microCode}-${nanoCode}`,
        vmLevel: vmLevel,
        microCode: microCode,
        nanoCode: nanoCode,
        microIx: microIndices.microIx,
        microIy: microIndices.microIy,
        nix: nanoIndices.nix,
        niy: nanoIndices.niy,
        polygon: polygon
    };
}

// Decodificar c√≥digo
function decodePostalCode(code) {
    const parts = code.split('-');
    if (parts.length !== 3) return null;
    
    const [vmLevel, microStr, nanoStr] = parts;
    
    // Buscar pol√≠gono por VM_LEVEL
    const polygon = rawZonas?.features.find(f => f.properties.VM_LEVEL === vmLevel);
    if (!polygon) return null;
    
    // Decodificar micro (2 caracteres cada uno)
    const microIx = decodeBase32(microStr.substring(0, 2));
    const microIy = decodeBase32(microStr.substring(2, 4));
    
    // Decodificar nano (2 caracteres cada uno)
    const nix = decodeBase32(nanoStr.substring(0, 2));
    const niy = decodeBase32(nanoStr.substring(2, 4));
    
    // Calcular coordenadas aproximadas (centro de la celda nano)
    const bounds = L.geoJSON(polygon).getBounds();
    
    // Tama√±o de celda micro
    const microSizeX = (bounds.getEast() - bounds.getWest()) / MICRO_RES;
    const microSizeY = (bounds.getNorth() - bounds.getSouth()) / MICRO_RES;
    
    // Tama√±o de celda nano dentro de micro
    const nanoSizeX = microSizeX / NANO_RES;
    const nanoSizeY = microSizeY / NANO_RES;
    
    // Calcular coordenadas del centro
    const centerLng = bounds.getWest() + 
        (microIx + (nix + 0.5) / NANO_RES) * microSizeX;
    
    const centerLat = bounds.getSouth() + 
        (microIy + (niy + 0.5) / NANO_RES) * microSizeY;
    
    // Calcular bounds de la celda nano
    const cellBounds = [
        [centerLat - nanoSizeY/2, centerLng - nanoSizeX/2],
        [centerLat - nanoSizeY/2, centerLng + nanoSizeX/2],
        [centerLat + nanoSizeY/2, centerLng + nanoSizeX/2],
        [centerLat + nanoSizeY/2, centerLng - nanoSizeX/2]
    ];
    
    return {
        lat: centerLat,
        lng: centerLng,
        cellBounds: cellBounds,
        vmLevel: vmLevel,
        microCode: microStr,
        nanoCode: nanoStr,
        polygon: polygon
    };
}

// ==================== VISUALIZACI√ìN ====================

function updateGridAndLabels() {
    clearTimeout(window.updateTimeout);
    
    document.getElementById('perf-warning').style.display = 'block';
    
    window.updateTimeout = setTimeout(() => {
        gridLayer.clearLayers();
        labelLayer.clearLayers();
        
        if (!rawZonas) {
            document.getElementById('perf-warning').style.display = 'none';
            return;
        }
        
        const z = mymap.getZoom();
        const bounds = mymap.getBounds();
        
        // Labels macro (VM_LEVEL)
        if (z >= 9 && z < 14 && labelsEnabled) {
            rawZonas.features.forEach(feature => {
                const featureBounds = L.geoJSON(feature).getBounds();
                if (bounds.intersects(featureBounds)) {
                    const center = featureBounds.getCenter();
                    const vmLevel = feature.properties.VM_LEVEL;
                    
                    L.marker(center, {
                        icon: L.divIcon({ 
                            className: 'watermark-label-fixed', 
                            html: vmLevel, 
                            iconSize: [60, 20] 
                        })
                    }).addTo(labelLayer);
                }
            });
        }
        
        // Grid micro (solo en zoom adecuado)
        if (z >= 14) {
            drawGridForVisiblePolygons(z);
        }
        
        document.getElementById('perf-warning').style.display = 'none';
    }, 50);
}

function drawGridForVisiblePolygons(zoom) {
    const bounds = mymap.getBounds();
    
    rawZonas.features.forEach(feature => {
        const featureBounds = L.geoJSON(feature).getBounds();
        if (!bounds.intersects(featureBounds)) return;
        
        const polygonBounds = featureBounds;
        
        // Dibujar grid micro
        const cellSizeX = (polygonBounds.getEast() - polygonBounds.getWest()) / MICRO_RES;
        const cellSizeY = (polygonBounds.getNorth() - polygonBounds.getSouth()) / MICRO_RES;
        
        let weight, opacity, color;
        if (zoom >= 14 && zoom < 17) {
            weight = 1.5;
            opacity = 0.4;
            color = '#3498db';
            
            // Dibujar l√≠neas verticales
            for (let i = 0; i <= MICRO_RES; i++) {
                const lng = polygonBounds.getWest() + i * cellSizeX;
                L.polyline([
                    [polygonBounds.getSouth(), lng],
                    [polygonBounds.getNorth(), lng]
                ], {color, weight, opacity}).addTo(gridLayer);
            }
            
            // Dibujar l√≠neas horizontales
            for (let j = 0; j <= MICRO_RES; j++) {
                const lat = polygonBounds.getSouth() + j * cellSizeY;
                L.polyline([
                    [lat, polygonBounds.getWest()],
                    [lat, polygonBounds.getEast()]
                ], {color, weight, opacity}).addTo(gridLayer);
            }
            
            // Labels micro (espaciados)
            if (labelsEnabled) {
                for (let i = 0; i < MICRO_RES; i += 3) {
                    for (let j = 0; j < MICRO_RES; j += 3) {
                        const centerLng = polygonBounds.getWest() + (i + 0.5) * cellSizeX;
                        const centerLat = polygonBounds.getSouth() + (j + 0.5) * cellSizeY;
                        
                        // Verificar si est√° dentro del pol√≠gono
                        if (leafletPip.pointInLayer([centerLng, centerLat], L.geoJSON(feature)).length > 0) {
                            const microCode = encodeBase32(i) + encodeBase32(j);
                            
                            L.marker([centerLat, centerLng], {
                                icon: L.divIcon({ 
                                    className: 'micro-label-fixed', 
                                    html: microCode, 
                                    iconSize: [40, 12] 
                                })
                            }).addTo(labelLayer);
                        }
                    }
                }
            }
        }
        
        // Grid nano (solo zoom alto, espaciado)
        if (zoom >= 17) {
            const nanoSizeX = cellSizeX / NANO_RES;
            const nanoSizeY = cellSizeY / NANO_RES;
            
            // Dibujar cada 5 l√≠neas para no saturar
            for (let i = 0; i <= MICRO_RES * NANO_RES; i += 5) {
                const lng = polygonBounds.getWest() + i * nanoSizeX;
                L.polyline([
                    [bounds.getSouth(), lng],
                    [bounds.getNorth(), lng]
                ], {color: '#2980b9', weight: 0.5, opacity: 0.2}).addTo(gridLayer);
            }
            
            for (let j = 0; j <= MICRO_RES * NANO_RES; j += 5) {
                const lat = polygonBounds.getSouth() + j * nanoSizeY;
                L.polyline([
                    [lat, bounds.getWest()],
                    [lat, bounds.getEast()]
                ], {color: '#2980b9', weight: 0.5, opacity: 0.2}).addTo(gridLayer);
            }
        }
    });
}

// ==================== EVENTO CLIC ====================

mymap.on("click", function (e) {
    selectionLayer.clearLayers();
    
    if (!rawZonas) return;
    
    // Verificar si est√° dentro de pol√≠gono postal
    const point = [e.latlng.lng, e.latlng.lat];
    const polygons = leafletPip.pointInLayer(point, L.geoJSON(rawZonas));
    
    if (polygons.length === 0) {
        // Fuera de √°rea postal
        showNoPostalAreaPopup(e.latlng);
        return;
    }
    
    // Dentro de √°rea postal
    const postalData = generatePostalCode(e.latlng.lat, e.latlng.lng);
    
    if (!postalData) return;
    
    const z = mymap.getZoom();
    
    // Destacar seg√∫n zoom
    if (z < 14) {
        // Destacar pol√≠gono completo
        L.geoJSON(postalData.polygon, {
            style: {
                color: "#1a73e8", 
                weight: 4, 
                fillColor: "#1a73e8",
                fillOpacity: 0.3
            }
        }).addTo(selectionLayer);
    } 
    else if (z >= 14 && z < 17) {
        // Destacar celda micro
        highlightMicroCell(postalData);
    }
    else {
        // Destacar celda nano
        highlightNanoCell(postalData);
    }
    
    // Mostrar popup con c√≥digo
    showPostalCodePopup(e.latlng, postalData);
});

function highlightMicroCell(postalData) {
    const bounds = L.geoJSON(postalData.polygon).getBounds();
    const cellSizeX = (bounds.getEast() - bounds.getWest()) / MICRO_RES;
    const cellSizeY = (bounds.getNorth() - bounds.getSouth()) / MICRO_RES;
    
    const cellBounds = [
        [bounds.getSouth() + postalData.microIy * cellSizeY, 
         bounds.getWest() + postalData.microIx * cellSizeX],
        [bounds.getSouth() + postalData.microIy * cellSizeY, 
         bounds.getWest() + (postalData.microIx + 1) * cellSizeX],
        [bounds.getSouth() + (postalData.microIy + 1) * cellSizeY, 
         bounds.getWest() + (postalData.microIx + 1) * cellSizeX],
        [bounds.getSouth() + (postalData.microIy + 1) * cellSizeY, 
         bounds.getWest() + postalData.microIx * cellSizeX]
    ];
    
    L.polygon(cellBounds, {
        color: "#3498db", 
        weight: 3, 
        fillColor: "#3498db",
        fillOpacity: 0.3
    }).addTo(selectionLayer);
    
    // Mostrar c√≥digo micro
    const center = [
        bounds.getSouth() + (postalData.microIy + 0.5) * cellSizeY,
        bounds.getWest() + (postalData.microIx + 0.5) * cellSizeX
    ];
    
    L.marker(center, {
        icon: L.divIcon({ 
            className: 'micro-selection-label', 
            html: `<div style="background: white; padding: 3px 6px; border: 2px solid #3498db; border-radius: 3px; color: #3498db; font-weight: bold;">${postalData.microCode}</div>`, 
            iconSize: [45, 25],
            iconAnchor: [22, 12]
        })
    }).addTo(selectionLayer);
}

function highlightNanoCell(postalData) {
    const bounds = L.geoJSON(postalData.polygon).getBounds();
    const microSizeX = (bounds.getEast() - bounds.getWest()) / MICRO_RES;
    const microSizeY = (bounds.getNorth() - bounds.getSouth()) / MICRO_RES;
    const nanoSizeX = microSizeX / NANO_RES;
    const nanoSizeY = microSizeY / NANO_RES;
    
    const cellBounds = [
        [bounds.getSouth() + (postalData.microIy + postalData.niy/NANO_RES) * microSizeY, 
         bounds.getWest() + (postalData.microIx + postalData.nix/NANO_RES) * microSizeX],
        [bounds.getSouth() + (postalData.microIy + postalData.niy/NANO_RES) * microSizeY, 
         bounds.getWest() + (postalData.microIx + (postalData.nix+1)/NANO_RES) * microSizeX],
        [bounds.getSouth() + (postalData.microIy + (postalData.niy+1)/NANO_RES) * microSizeY, 
         bounds.getWest() + (postalData.microIx + (postalData.nix+1)/NANO_RES) * microSizeX],
        [bounds.getSouth() + (postalData.microIy + (postalData.niy+1)/NANO_RES) * microSizeY, 
         bounds.getWest() + (postalData.microIx + postalData.nix/NANO_RES) * microSizeX]
    ];
    
    L.polygon(cellBounds, {
        color: "#2980b9", 
        weight: 2, 
        fillColor: "#2980b9",
        fillOpacity: 0.4
    }).addTo(selectionLayer);
    
    // Mostrar c√≥digo nano
    const center = [
        bounds.getSouth() + (postalData.microIy + (postalData.niy + 0.5)/NANO_RES) * microSizeY,
        bounds.getWest() + (postalData.microIx + (postalData.nix + 0.5)/NANO_RES) * microSizeX
    ];
    
    L.marker(center, {
        icon: L.divIcon({ 
            className: 'nano-selection-label', 
            html: `<div style="background: white; padding: 2px 5px; border: 2px solid #2980b9; border-radius: 3px; color: #2980b9; font-weight: bold;">${postalData.nanoCode}</div>`, 
            iconSize: [40, 22],
            iconAnchor: [20, 11]
        })
    }).addTo(selectionLayer);
}

function showNoPostalAreaPopup(latlng) {
    const popup = L.popup()
        .setLatLng([latlng.lat + 0.0004, latlng.lng])
        .setContent(`
            <div style="text-align:center; padding: 15px;">
                <div style="color: #e74c3c; font-size: 16px; margin-bottom: 10px;">
                    ‚ö†Ô∏è SIN C√ìDIGO POSTAL
                </div>
                <div style="color: #7f8c8d; font-size: 13px; margin-bottom: 15px;">
                    Esta ubicaci√≥n est√° fuera de las zonas postales definidas
                </div>
                <div style="font-family: monospace; font-size: 12px; color: #666; background: #f8f9fa; padding: 8px; border-radius: 4px; margin: 10px 0;">
                    ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}
                </div>
                <div>
                    <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                    <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç Ubicaci√≥n sin c√≥digo postal\nGPS: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`)}')">üí¨ WS</button>
                </div>
            </div>
        `)
        .openOn(mymap);
}

function showPostalCodePopup(latlng, postalData) {
    const props = postalData.polygon.properties;
    const areaKm2 = props.AREA ? (props.AREA / 1000000).toFixed(1) : '';
    
    const popupContent = `
        <div style="text-align:center; padding: 15px; min-width: 280px;">
            <div style="font-size: 14px; color: #3498db; margin-bottom: 5px;">
                üè∑Ô∏è C√ìDIGO POSTAL
            </div>
            
            <div class="code-display">
                ${postalData.fullCode}
            </div>
            
            <div class="info-box">
                <div><strong>${props.VM_LEVEL}</strong> - ${props.PROV_NOMB || 'Panam√°'}</div>
                ${areaKm2 ? `<div>√Årea: ${areaKm2} km¬≤</div>` : ''}
                <div>Micro: ${postalData.microCode} (${postalData.microIx},${postalData.microIy})</div>
                <div>Nano: ${postalData.nanoCode} (${postalData.nix},${postalData.niy})</div>
            </div>
            
            <div style="font-family: monospace; font-size: 11px; color: #666; background: #f8f9fa; padding: 6px; border-radius: 3px; margin: 8px 0;">
                üìç ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}
            </div>
            
            <div>
                <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${latlng.lat},${latlng.lng}')">üìç MAPS</button>
                <button class="btn-ws" onclick="window.open('https://wa.me/?text=${encodeURIComponent(`üìç C√≥digo Postal: ${postalData.fullCode}\nüìå GPS: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}\nüó∫Ô∏è ${props.PROV_NOMB || ''}`)}')">üí¨ WS</button>
            </div>
            
            <div style="margin-top: 10px; font-size: 10px; color: #95a5a6;">
                Base32 | ${MICRO_RES}√ó${MICRO_RES} micro | ${NANO_RES}√ó${NANO_RES} nano
            </div>
        </div>
    `;
    
    const popup = L.popup()
        .setLatLng([latlng.lat + 0.0004, latlng.lng])
        .setContent(popupContent)
        .openOn(mymap);
    
    popup.on('remove', () => {
        selectionLayer.clearLayers();
    });
}

// ==================== BUSCADOR ====================

document.getElementById('search-btn').addEventListener('click', () => {
    const code = document.getElementById('search-input').value.trim().toUpperCase();
    
    if (!code || !rawZonas) return;
    
    const decoded = decodePostalCode(code);
    
    if (!decoded) {
        alert('C√≥digo postal no encontrado: ' + code);
        return;
    }
    
    selectionLayer.clearLayers();
    
    // Centrar mapa
    mymap.setView([decoded.lat, decoded.lng], 16);
    
    // Destacar celda
    L.polygon(decoded.cellBounds, {
        color: '#e74c3c',
        weight: 3,
        fillColor: '#e74c3c',
        fillOpacity: 0.3
    }).addTo(selectionLayer);
    
    // Mostrar c√≥digo en input
    document.getElementById('search-input').value = code;
});

// ==================== CARGA DE DATOS ====================

$.getJSON("estafetas.geojson", d => { 
    rawZonas = d; 
    
    L.geoJSON(d, {
        style: {color: "#2c3e50", weight: 1, fillOpacity: 0.03},
        interactive: false
    }).addTo(zonasGeoLayer);
    
    updateGridAndLabels();
});

// ==================== CONTROLES ====================

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', '', c);
        b.innerHTML = 'üéØ';
        b.style.cssText = 'width:30px;height:30px;line-height:30px;text-align:center;display:block;background:white;border-radius:5px;cursor:pointer;';
        b.onclick = () => mymap.locate({setView:true, maxZoom:16});
        return c;
    }
});
mymap.addControl(new LocateControl());

// Toggle labels
$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    updateGridAndLabels();
});

// Eventos optimizados
let moveTimeout;
mymap.on('moveend', () => {
    clearTimeout(moveTimeout);
    moveTimeout = setTimeout(updateGridAndLabels, 200);
});

mymap.on('zoomend', updateGridAndLabels);
mymap.on('zoomstart', () => selectionLayer.clearLayers());

// GPS
mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    
    L.circleMarker(e.latlng, {
        radius: 8,
        color: '#3498db',
        fillColor: '#3498db',
        fillOpacity: 0.7
    }).addTo(userLocationLayer);
    
    // Generar c√≥digo para ubicaci√≥n
    const postalData = generatePostalCode(e.latlng.lat, e.latlng.lng);
    
    if (postalData) {
        const popup = L.popup()
            .setLatLng(e.latlng)
            .setContent(`
                <div style="text-align:center; padding: 10px;">
                    <div style="font-weight:bold; margin-bottom: 5px;">üìç Tu ubicaci√≥n</div>
                    <div class="code-display" style="font-size: 14px;">${postalData.fullCode}</div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        ${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}
                    </div>
                </div>
            `)
            .openOn(mymap);
    }
});

// Inicializar
updateGridAndLabels();
</script>
</body>
</html>
